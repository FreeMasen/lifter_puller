==============================================================================
./buffer.lua
==============================================================================

      --- binary 0011 1111 which represents the utf-8 continue mask
    2 local CONT_MASK = 63

    2 local Buffer = {}

    2 Buffer.__index = Buffer

    2 function Buffer.new(s)
   16     local ret = {
   16         stream = s,
   16         current_idx = 1,
   16         len = #s,
          }
   16     setmetatable(ret,  Buffer)
   16     return ret
      end

      ---Check if the buffer has reached the last character
    2 function Buffer:at_end()
   89     return self.current_idx >= self.len
      end

    2 function Buffer:current_char()
   25     return string.sub(self.stream, self.current_idx, self.current_idx)
      end

      ---Get the current byte
    2 function Buffer:current_byte()
    7     return string.byte(self.stream, self.current_idx, self.current_idx)
      end

      ---Get the next byte, with no regard for any string encoding
      ---returns nil,string if idx is past the end of the buffer
      ---@return number|nil, string|nil
    2 function Buffer:next_byte()
    3     local idx = self.current_idx + 1
    3     if idx >= self.len then
****0         return nil, 'At EOF'
          end
    3     return string.byte(self.stream, idx, idx)
      end

      ---Move the buffer forward a number of bytes, returning the substring
      ---that was just passed. Returns nil, string ct would move past the end of the buffer
      ---@param ct number The number of bytes to move forward
      ---@return string|nil,string|nil
    2 function Buffer:advance(ct)
  858     local new_idx = self.current_idx + ct
  858     if new_idx > self.len then
   13         return nil, 'Would pass EOF'
          end
          local s
  845     s = string.sub(self.stream, self.current_idx, new_idx-1)
          -- if ct == 1 then
          --     s = string.sub(self.stream, self.current_idx, self.current_idx)
          -- else
          -- end
  845     self.current_idx = new_idx
  845     return s
      end

      ---Check if the buffer currently starts with the provided string
      ---@param s string The string to match
      ---@return boolean
    2 function Buffer:starts_with(s)
  123     local sub = string.sub(self.stream, self.current_idx)
  246     local start, _stop = string.find(
  123         sub,
  123         string.format('^%s', s)
          )
  123     return start ~= nil
      end


    2 function Buffer:at_cdata_start()
    4     local slice = string.sub(
    2         self.stream,
    2         self.current_idx,
    2         self.current_idx + #'<![CDATA')
****0     return 
    2         slice == '<![CDATA['
      end
      ---Consume the provided string, if the buffer isn't at
      ---the current string will return nil, string
      ---@param s string The string to match
      ---@return string|nil,string|nil
    2 function Buffer:consume_str(s)
   40     local s2 = string.match(self.stream, string.format('^%s', s), self.current_idx)
   40     if not s2 or s2 == '' then
    5         return nil, string.format('mismatched consume: "%s" vs "%s"', s, s2)
          end
   35     self:advance(#s2)
   35     return s2
      end

      --- Consume bytes while the closure returns true
      ---@param f fun(b:string):boolean
      ---@return string|nil,string|nil
    2 function Buffer:consume_while(f)
    8     local pos = self.current_idx
   89     while not self:at_end() do
   89         local slice = string.sub(self.stream, pos, pos)
   89         if f(slice) then
   81             pos = pos + 1
              else
    8             local ret = string.sub(self.stream, self.current_idx, pos - 1)
    8             self:advance(pos - self.current_idx)
    8             return ret
              end
          end
      end


    2 function Buffer:consume_until(s)
    4     local slice = string.sub(self.stream, self.current_idx)

    4     local start, stop = string.find(slice, s)
    4     if start == nil then
****0         return nil, 'pattern not found'
          end
    4     local ret = string.sub(slice, 1, start-1)
    4     self.current_idx = self.current_idx + #ret
    4     return ret
      end

      --- Accumulate and mask the continue byte
      ---@param acc number The number to accumulate into
      ---@param b number The byte to accumulate
      local function acc_cont_byte(acc, b)
  810     return (acc << 6) | (b & CONT_MASK)
      end

      --- Returns a utf-8 encoded
      --- character as an up to 4 byte integer
    2 function Buffer:next_utf8_int()
  684     local idx = self.current_idx
  684     local x = string.byte(self.stream, idx, idx) or 0
  684     if x < 128 then
  104         return x, 1
          end
  580     local len = 4
  580     if x < 0xE0 then -- 0xE0 == 1110 0000
   94         len = 2
  486     elseif x < 0xF0 then -- 0xF0 == 1111 0000
  256         len = 3
          end
  580     local y, z, w = string.byte(self.stream, idx + 2, idx + len + 2)
  580     local init = x & (0x7F >> 2)
  580     if len == 2 then
   94         return acc_cont_byte(init, y or 0), len
          end
  486     local y_z = acc_cont_byte(y & CONT_MASK, z or 0)
  486     if len == 3 then
  256         return (init << 12) | y_z, len
          end
  230     local y_z_w = acc_cont_byte(y_z, w or 0)
  230     return (init & 7) << 18 | y_z_w, len
      end

    2 function Buffer:skip_whitespace()
   62     local whitespace = string.match(self.stream, '^%s*', self.current_idx)
   62     self:advance(#whitespace)
   62     return #whitespace > 0
      end

    2 return Buffer

==============================================================================
./event.lua
==============================================================================

    1 local event_type = {
    1     declaration = 'Declaration',
    1     open_tag = 'OpenTag',
    1     close_tag = 'CloseTag',
    1     tag_end = 'TagEnd',
    1     attribute = 'Attribute',
    1     c_data = 'CData',
    1     comment = 'Comment',
    1     processing_instruction = 'ProcessingInstruction',
    1     doctype_start = 'DocTypeStart',
    1     doctype = 'DocType',
    1     entity_declaration = 'EntityDeclaration',
    1     doctype_end = 'DocTypeEnd',
    1     cdata = "CData",
    1     eof = "EOF",
      }

      ---@class Event
    1 local Event = {}

    1 Event.__index = Event

      ---
      ---@param e table
      ---@return Event
      local function _create(e)
   16     setmetatable(e, Event)
   16     return e
      end

      ---ctor for Declaration
      ---@param version string
      ---@param encoding string
      ---@param standalone boolean
      ---@return Event
    1 function Event.decl(version, encoding, standalone)
    2     return _create{
    1         ty = event_type.declaration,
    1         version = version,
    1         encoding = encoding,
    1         standalone = standalone,
          }
      end

      ---ctor for processing instruction
      ---@param target string
      ---@param content string
      ---@return Event
    1 function Event.pi(target, content)
    4     return _create{
    2         ty = event_type.processing_instruction,
    2         target = target,
    2         content = content,
          }
      end

      ---ctor for comment
      ---@param text string
      ---@return Event
    1 function Event.comment(text)
    2     return _create{
    1         ty = event_type.comment,
    1         text = text,
          }
      end

      ---ctor for doctype start
      ---@param name string
      ---@param external_id string
      ---@param external_value string[] 1-2 entry list table
      ---@return Event
    1 function Event.doctype_start(name, external_id, external_value)
    4     return _create{
    2         ty = event_type.doctype_start,
    2         name = name,
    2         external_id = external_id,
    2         external_value = external_value,
          }
      end

      ---ctor for empty doctype
      ---@param name string
      ---@param external_id string
      ---@param external_value string[]
      ---@return Event
    1 function Event.empty_doctype(name, external_id, external_value)
    4     return _create{
    2         ty = event_type.doctype,
    2         name = name,
    2         external_id = external_id,
    2         external_value = external_value,
          }
      end

      ---ctor for entity declaration
      ---@param name string
      ---@param external_id string
      ---@param external_value string[]
      ---@param ndata string
      ---@return Event
    1 function Event.entity_declaration(name, external_id, external_value, ndata)
    6     return _create{
    3         ty = event_type.entity_declaration,
    3         name = name,
    3         external_id = external_id,
    3         external_value = external_value,
    3         ndata = ndata,
          }
      end

      ---ctor for DocTypeEnd
      ---@return Event
    1 function Event.doctype_end()
    2     return _create{
    1         ty = event_type.doctype_end
          }
      end

      ---<name
      ---<prefix:name
      ---@param prefix string
      ---@param name string
      ---@return Event
    1 function Event.open_tag(prefix, name)
    2     return _create{
    1         ty = event_type.open_tag,
    1         prefix = prefix,
    1         name = name,
          }
      end

      --- attr="value"
      --- prefix:attr="value"
      ---@param prefix string
      ---@param name string
      ---@param value string
      ---@return Event
    1 function Event.attr(prefix, name, value)
****0     return  _create{
              ty = event_type.attribute,
              prefix = prefix,
              name = name,
****0         value = value
          }
      end

      --- </name>
      ---@param prefix string
      ---@param name string
      ---@return Event
    1 function Event.close_tag(prefix, name)
    2     return _create{
    1         ty = event_type.close_tag,
    1         prefix = prefix,
    1         name = name,
          }
      end

      ---
      ---@param is_empty boolean
      ---@return Event
    1 function Event.tag_end(is_empty)
    2     return _create{
    1         ty = event_type.tag_end,
    1         is_empty = is_empty,
          }
      end

      ---
      ---@param text string
      ---@return Event
    1 function Event.cdata(text)
    2     return _create{
    1         ty = event_type.cdata,
    1         text = text,
          }
      end

      ---End of stream reached
      ---@return Event
    1 function Event.eof()
****0     return _create{ ty = event_type.eof }

      end

    1 return {
    1     Event = Event,
    1     event_type = event_type,
    1 }

==============================================================================
./spec/char_maps.lua
==============================================================================
    1 local three_byte = {
    1     ['áŽ '] = {0xe1, 0x8e, 0xa0},
    1     ['áŽ¡'] = {0xe1, 0x8e, 0xa1},
    1     ['áŽ¢'] = {0xe1, 0x8e, 0xa2},
    1     ['áŽ£'] = {0xe1, 0x8e, 0xa3},
    1     ['áŽ¤'] = {0xe1, 0x8e, 0xa4},
    1     ['áŽ¥'] = {0xe1, 0x8e, 0xa5},
    1     ['áŽ¦'] = {0xe1, 0x8e, 0xa6},
    1     ['áŽ§'] = {0xe1, 0x8e, 0xa7},
    1     ['áŽ¨'] = {0xe1, 0x8e, 0xa8},
    1     ['áŽ©'] = {0xe1, 0x8e, 0xa9},
    1     ['áŽª'] = {0xe1, 0x8e, 0xaa},
    1     ['áŽ«'] = {0xe1, 0x8e, 0xab},
    1     ['áŽ¬'] = {0xe1, 0x8e, 0xac},
    1     ['áŽ­'] = {0xe1, 0x8e, 0xad},
    1     ['áŽ®'] = {0xe1, 0x8e, 0xae},
    1     ['áŽ¯'] = {0xe1, 0x8e, 0xaf},
    1     ['áŽ°'] = {0xe1, 0x8e, 0xb0},
    1     ['áŽ±'] = {0xe1, 0x8e, 0xb1},
    1     ['áŽ²'] = {0xe1, 0x8e, 0xb2},
    1     ['áŽ³'] = {0xe1, 0x8e, 0xb3},
    1     ['áŽ´'] = {0xe1, 0x8e, 0xb4},
    1     ['áŽµ'] = {0xe1, 0x8e, 0xb5},
    1     ['áŽ¶'] = {0xe1, 0x8e, 0xb6},
    1     ['áŽ·'] = {0xe1, 0x8e, 0xb7},
    1     ['áŽ¸'] = {0xe1, 0x8e, 0xb8},
    1     ['áŽ¹'] = {0xe1, 0x8e, 0xb9},
    1     ['áŽº'] = {0xe1, 0x8e, 0xba},
    1     ['áŽ»'] = {0xe1, 0x8e, 0xbb},
    1     ['áŽ¼'] = {0xe1, 0x8e, 0xbc},
    1     ['áŽ½'] = {0xe1, 0x8e, 0xbd},
    1     ['áŽ¾'] = {0xe1, 0x8e, 0xbe},
    1     ['áŽ¿'] = {0xe1, 0x8e, 0xbf},
    1     ['á€'] = {0xe1, 0x8f, 0x80},
    1     ['á'] = {0xe1, 0x8f, 0x81},
    1     ['á‚'] = {0xe1, 0x8f, 0x82},
    1     ['áƒ'] = {0xe1, 0x8f, 0x83},
    1     ['á„'] = {0xe1, 0x8f, 0x84},
    1     ['á…'] = {0xe1, 0x8f, 0x85},
    1     ['á†'] = {0xe1, 0x8f, 0x86},
    1     ['á‡'] = {0xe1, 0x8f, 0x87},
    1     ['áˆ'] = {0xe1, 0x8f, 0x88},
    1     ['á‰'] = {0xe1, 0x8f, 0x89},
    1     ['áŠ'] = {0xe1, 0x8f, 0x8a},
    1     ['á‹'] = {0xe1, 0x8f, 0x8b},
    1     ['áŒ'] = {0xe1, 0x8f, 0x8c},
    1     ['á'] = {0xe1, 0x8f, 0x8d},
    1     ['áŽ'] = {0xe1, 0x8f, 0x8e},
    1     ['á'] = {0xe1, 0x8f, 0x8f},
    1     ['á'] = {0xe1, 0x8f, 0x90},
    1     ['á‘'] = {0xe1, 0x8f, 0x91},
    1     ['á’'] = {0xe1, 0x8f, 0x92},
    1     ['á“'] = {0xe1, 0x8f, 0x93},
    1     ['á”'] = {0xe1, 0x8f, 0x94},
    1     ['á•'] = {0xe1, 0x8f, 0x95},
    1     ['á–'] = {0xe1, 0x8f, 0x96},
    1     ['á—'] = {0xe1, 0x8f, 0x97},
    1     ['á˜'] = {0xe1, 0x8f, 0x98},
    1     ['á™'] = {0xe1, 0x8f, 0x99},
    1     ['áš'] = {0xe1, 0x8f, 0x9a},
    1     ['á›'] = {0xe1, 0x8f, 0x9b},
    1     ['áœ'] = {0xe1, 0x8f, 0x9c},
    1     ['á'] = {0xe1, 0x8f, 0x9d},
    1     ['áž'] = {0xe1, 0x8f, 0x9e},
    1     ['áŸ'] = {0xe1, 0x8f, 0x9f},
    1     ['á '] = {0xe1, 0x8f, 0xa0},
    1     ['á¡'] = {0xe1, 0x8f, 0xa1},
    1     ['á¢'] = {0xe1, 0x8f, 0xa2},
    1     ['á£'] = {0xe1, 0x8f, 0xa3},
    1     ['á¤'] = {0xe1, 0x8f, 0xa4},
    1     ['á¥'] = {0xe1, 0x8f, 0xa5},
    1     ['á¦'] = {0xe1, 0x8f, 0xa6},
    1     ['á§'] = {0xe1, 0x8f, 0xa7},
    1     ['á¨'] = {0xe1, 0x8f, 0xa8},
    1     ['á©'] = {0xe1, 0x8f, 0xa9},
    1     ['áª'] = {0xe1, 0x8f, 0xaa},
    1     ['á«'] = {0xe1, 0x8f, 0xab},
    1     ['á¬'] = {0xe1, 0x8f, 0xac},
    1     ['á­'] = {0xe1, 0x8f, 0xad},
    1     ['á®'] = {0xe1, 0x8f, 0xae},
    1     ['á¯'] = {0xe1, 0x8f, 0xaf},
    1     ['á°'] = {0xe1, 0x8f, 0xb0},
    1     ['á±'] = {0xe1, 0x8f, 0xb1},
    1     ['á²'] = {0xe1, 0x8f, 0xb2},
    1     ['á³'] = {0xe1, 0x8f, 0xb3},
    1     ['á´'] = {0xe1, 0x8f, 0xb4},
    1     ['áµ'] = {0xe1, 0x8f, 0xb5},
    1     ['á¶'] = {0xe1, 0x8f, 0xb6},
    1     ['á·'] = {0xe1, 0x8f, 0xb7},
    1     ['á¸'] = {0xe1, 0x8f, 0xb8},
    1     ['á¹'] = {0xe1, 0x8f, 0xb9},
    1     ['áº'] = {0xe1, 0x8f, 0xba},
    1     ['á»'] = {0xe1, 0x8f, 0xbb},
    1     ['á¼'] = {0xe1, 0x8f, 0xbc},
    1     ['á½'] = {0xe1, 0x8f, 0xbd},
    1     ['á¾'] = {0xe1, 0x8f, 0xbe},
    1     ['á¿'] = {0xe1, 0x8f, 0xbf},
    1     ['á€'] = {0xe1, 0x90, 0x80},
    1     ['á'] = {0xe1, 0x90, 0x81},
    1     ['á‚'] = {0xe1, 0x90, 0x82},
    1     ['áƒ'] = {0xe1, 0x90, 0x83},
    1     ['á„'] = {0xe1, 0x90, 0x84},
    1     ['á…'] = {0xe1, 0x90, 0x85},
    1     ['á†'] = {0xe1, 0x90, 0x86},
    1     ['á‡'] = {0xe1, 0x90, 0x87},
    1     ['áˆ'] = {0xe1, 0x90, 0x88},
    1     ['á‰'] = {0xe1, 0x90, 0x89},
    1     ['áŠ'] = {0xe1, 0x90, 0x8a},
    1     ['á‹'] = {0xe1, 0x90, 0x8b},
    1     ['áŒ'] = {0xe1, 0x90, 0x8c},
    1     ['á'] = {0xe1, 0x90, 0x8d},
    1     ['áŽ'] = {0xe1, 0x90, 0x8e},
    1     ['á'] = {0xe1, 0x90, 0x8f},
    1     ['á'] = {0xe1, 0x90, 0x90},
    1     ['á‘'] = {0xe1, 0x90, 0x91},
    1     ['á’'] = {0xe1, 0x90, 0x92},
    1     ['á“'] = {0xe1, 0x90, 0x93},
    1     ['á”'] = {0xe1, 0x90, 0x94},
    1     ['á•'] = {0xe1, 0x90, 0x95},
    1     ['á–'] = {0xe1, 0x90, 0x96},
    1     ['á—'] = {0xe1, 0x90, 0x97},
    1     ['á˜'] = {0xe1, 0x90, 0x98},
    1     ['á™'] = {0xe1, 0x90, 0x99},
    1     ['áš'] = {0xe1, 0x90, 0x9a},
    1     ['á›'] = {0xe1, 0x90, 0x9b},
    1     ['áœ'] = {0xe1, 0x90, 0x9c},
    1     ['á'] = {0xe1, 0x90, 0x9d},
    1     ['áž'] = {0xe1, 0x90, 0x9e},
    1     ['áŸ'] = {0xe1, 0x90, 0x9f},
    1     ['á '] = {0xe1, 0x90, 0xa0},
    1     ['á¡'] = {0xe1, 0x90, 0xa1},
    1     ['á¢'] = {0xe1, 0x90, 0xa2},
    1     ['á£'] = {0xe1, 0x90, 0xa3},
    1     ['á¤'] = {0xe1, 0x90, 0xa4},
    1     ['á¥'] = {0xe1, 0x90, 0xa5},
    1     ['á¦'] = {0xe1, 0x90, 0xa6},
    1     ['á§'] = {0xe1, 0x90, 0xa7},
    1     ['á¨'] = {0xe1, 0x90, 0xa8},
    1     ['á©'] = {0xe1, 0x90, 0xa9},
    1     ['áª'] = {0xe1, 0x90, 0xaa},
    1     ['á«'] = {0xe1, 0x90, 0xab},
    1     ['á¬'] = {0xe1, 0x90, 0xac},
    1     ['á­'] = {0xe1, 0x90, 0xad},
    1     ['á®'] = {0xe1, 0x90, 0xae},
    1     ['á¯'] = {0xe1, 0x90, 0xaf},
    1     ['á°'] = {0xe1, 0x90, 0xb0},
    1     ['á±'] = {0xe1, 0x90, 0xb1},
    1     ['á²'] = {0xe1, 0x90, 0xb2},
    1     ['á³'] = {0xe1, 0x90, 0xb3},
    1     ['á´'] = {0xe1, 0x90, 0xb4},
    1     ['áµ'] = {0xe1, 0x90, 0xb5},
    1     ['á¶'] = {0xe1, 0x90, 0xb6},
    1     ['á·'] = {0xe1, 0x90, 0xb7},
    1     ['á¸'] = {0xe1, 0x90, 0xb8},
    1     ['á¹'] = {0xe1, 0x90, 0xb9},
    1     ['áº'] = {0xe1, 0x90, 0xba},
    1     ['á»'] = {0xe1, 0x90, 0xbb},
    1     ['á¼'] = {0xe1, 0x90, 0xbc},
    1     ['á½'] = {0xe1, 0x90, 0xbd},
    1     ['á¾'] = {0xe1, 0x90, 0xbe},
    1     ['á¿'] = {0xe1, 0x90, 0xbf},
    1     ['á‘€'] = {0xe1, 0x91, 0x80},
    1     ['á‘'] = {0xe1, 0x91, 0x81},
    1     ['á‘‚'] = {0xe1, 0x91, 0x82},
    1     ['á‘ƒ'] = {0xe1, 0x91, 0x83},
    1     ['á‘„'] = {0xe1, 0x91, 0x84},
    1     ['á‘…'] = {0xe1, 0x91, 0x85},
    1     ['á‘†'] = {0xe1, 0x91, 0x86},
    1     ['á‘‡'] = {0xe1, 0x91, 0x87},
    1     ['á‘ˆ'] = {0xe1, 0x91, 0x88},
    1     ['á‘‰'] = {0xe1, 0x91, 0x89},
    1     ['á‘Š'] = {0xe1, 0x91, 0x8a},
    1     ['á‘‹'] = {0xe1, 0x91, 0x8b},
    1     ['á‘Œ'] = {0xe1, 0x91, 0x8c},
    1     ['á‘'] = {0xe1, 0x91, 0x8d},
    1     ['á‘Ž'] = {0xe1, 0x91, 0x8e},
    1     ['á‘'] = {0xe1, 0x91, 0x8f},
    1     ['á‘'] = {0xe1, 0x91, 0x90},
    1     ['á‘‘'] = {0xe1, 0x91, 0x91},
    1     ['á‘’'] = {0xe1, 0x91, 0x92},
    1     ['á‘“'] = {0xe1, 0x91, 0x93},
    1     ['á‘”'] = {0xe1, 0x91, 0x94},
    1     ['á‘•'] = {0xe1, 0x91, 0x95},
    1     ['á‘–'] = {0xe1, 0x91, 0x96},
    1     ['á‘—'] = {0xe1, 0x91, 0x97},
    1     ['á‘˜'] = {0xe1, 0x91, 0x98},
    1     ['á‘™'] = {0xe1, 0x91, 0x99},
    1     ['á‘š'] = {0xe1, 0x91, 0x9a},
    1     ['á‘›'] = {0xe1, 0x91, 0x9b},
    1     ['á‘œ'] = {0xe1, 0x91, 0x9c},
    1     ['á‘'] = {0xe1, 0x91, 0x9d},
    1     ['á‘ž'] = {0xe1, 0x91, 0x9e},
    1     ['á‘Ÿ'] = {0xe1, 0x91, 0x9f},
    1     ['á‘ '] = {0xe1, 0x91, 0xa0},
    1     ['á‘¡'] = {0xe1, 0x91, 0xa1},
    1     ['á‘¢'] = {0xe1, 0x91, 0xa2},
    1     ['á‘£'] = {0xe1, 0x91, 0xa3},
    1     ['á‘¤'] = {0xe1, 0x91, 0xa4},
    1     ['á‘¥'] = {0xe1, 0x91, 0xa5},
    1     ['á‘¦'] = {0xe1, 0x91, 0xa6},
    1     ['á‘§'] = {0xe1, 0x91, 0xa7},
    1     ['á‘¨'] = {0xe1, 0x91, 0xa8},
    1     ['á‘©'] = {0xe1, 0x91, 0xa9},
    1     ['á‘ª'] = {0xe1, 0x91, 0xaa},
    1     ['á‘«'] = {0xe1, 0x91, 0xab},
    1     ['á‘¬'] = {0xe1, 0x91, 0xac},
    1     ['á‘­'] = {0xe1, 0x91, 0xad},
    1     ['á‘®'] = {0xe1, 0x91, 0xae},
    1     ['á‘¯'] = {0xe1, 0x91, 0xaf},
    1     ['á‘°'] = {0xe1, 0x91, 0xb0},
    1     ['á‘±'] = {0xe1, 0x91, 0xb1},
    1     ['á‘²'] = {0xe1, 0x91, 0xb2},
    1     ['á‘³'] = {0xe1, 0x91, 0xb3},
    1     ['á‘´'] = {0xe1, 0x91, 0xb4},
    1     ['á‘µ'] = {0xe1, 0x91, 0xb5},
    1     ['á‘¶'] = {0xe1, 0x91, 0xb6},
    1     ['á‘·'] = {0xe1, 0x91, 0xb7},
    1     ['á‘¸'] = {0xe1, 0x91, 0xb8},
    1     ['á‘¹'] = {0xe1, 0x91, 0xb9},
    1     ['á‘º'] = {0xe1, 0x91, 0xba},
    1     ['á‘»'] = {0xe1, 0x91, 0xbb},
    1     ['á‘¼'] = {0xe1, 0x91, 0xbc},
    1     ['á‘½'] = {0xe1, 0x91, 0xbd},
    1     ['á‘¾'] = {0xe1, 0x91, 0xbe},
    1     ['á‘¿'] = {0xe1, 0x91, 0xbf},
    1     ['á’€'] = {0xe1, 0x92, 0x80},
    1     ['á’'] = {0xe1, 0x92, 0x81},
    1     ['á’‚'] = {0xe1, 0x92, 0x82},
    1     ['á’ƒ'] = {0xe1, 0x92, 0x83},
    1     ['á’„'] = {0xe1, 0x92, 0x84},
    1     ['á’…'] = {0xe1, 0x92, 0x85},
    1     ['á’†'] = {0xe1, 0x92, 0x86},
    1     ['á’‡'] = {0xe1, 0x92, 0x87},
    1     ['á’ˆ'] = {0xe1, 0x92, 0x88},
    1     ['á’‰'] = {0xe1, 0x92, 0x89},
    1     ['á’Š'] = {0xe1, 0x92, 0x8a},
    1     ['á’‹'] = {0xe1, 0x92, 0x8b},
    1     ['á’Œ'] = {0xe1, 0x92, 0x8c},
    1     ['á’'] = {0xe1, 0x92, 0x8d},
    1     ['á’Ž'] = {0xe1, 0x92, 0x8e},
    1     ['á’'] = {0xe1, 0x92, 0x8f},
    1     ['á’'] = {0xe1, 0x92, 0x90},
    1     ['á’‘'] = {0xe1, 0x92, 0x91},
    1     ['á’’'] = {0xe1, 0x92, 0x92},
    1     ['á’“'] = {0xe1, 0x92, 0x93},
    1     ['á’”'] = {0xe1, 0x92, 0x94},
    1     ['á’•'] = {0xe1, 0x92, 0x95},
    1     ['á’–'] = {0xe1, 0x92, 0x96},
    1     ['á’—'] = {0xe1, 0x92, 0x97},
    1     ['á’˜'] = {0xe1, 0x92, 0x98},
    1     ['á’™'] = {0xe1, 0x92, 0x99},
    1     ['á’š'] = {0xe1, 0x92, 0x9a},
    1     ['á’›'] = {0xe1, 0x92, 0x9b},
    1     ['á’œ'] = {0xe1, 0x92, 0x9c},
    1     ['á’'] = {0xe1, 0x92, 0x9d},
    1     ['á’ž'] = {0xe1, 0x92, 0x9e},
    1     ['á’Ÿ'] = {0xe1, 0x92, 0x9f},
      }

    1 local two_byte = {
    1     ['Â¡'] = {0xc2, 0xa1},
    1     ['Â¢'] = {0xc2, 0xa2},
    1     ['Â£'] = {0xc2, 0xa3},
    1     ['Â¤'] = {0xc2, 0xa4},
    1     ['Â¥'] = {0xc2, 0xa5},
    1     ['Â¦'] = {0xc2, 0xa6},
    1     ['Â§'] = {0xc2, 0xa7},
    1     ['Â¨'] = {0xc2, 0xa8},
    1     ['Â©'] = {0xc2, 0xa9},
    1     ['Âª'] = {0xc2, 0xaa},
    1     ['Â«'] = {0xc2, 0xab},
    1     ['Â¬'] = {0xc2, 0xac},
    1     ['Â®'] = {0xc2, 0xae},
    1     ['Â¯'] = {0xc2, 0xaf},
    1     ['Â°'] = {0xc2, 0xb0},
    1     ['Â±'] = {0xc2, 0xb1},
    1     ['Â²'] = {0xc2, 0xb2},
    1     ['Â³'] = {0xc2, 0xb3},
    1     ['Â´'] = {0xc2, 0xb4},
    1     ['Âµ'] = {0xc2, 0xb5},
    1     ['Â¶'] = {0xc2, 0xb6},
    1     ['Â·'] = {0xc2, 0xb7},
    1     ['Â¸'] = {0xc2, 0xb8},
    1     ['Â¹'] = {0xc2, 0xb9},
    1     ['Âº'] = {0xc2, 0xba},
    1     ['Â»'] = {0xc2, 0xbb},
    1     ['Â¼'] = {0xc2, 0xbc},
    1     ['Â½'] = {0xc2, 0xbd},
    1     ['Â¾'] = {0xc2, 0xbe},
    1     ['Â¿'] = {0xc2, 0xbf},
    1     ['Ã€'] = {0xc3, 0x80},
    1     ['Ã'] = {0xc3, 0x81},
    1     ['Ã‚'] = {0xc3, 0x82},
    1     ['Ãƒ'] = {0xc3, 0x83},
    1     ['Ã„'] = {0xc3, 0x84},
    1     ['Ã…'] = {0xc3, 0x85},
    1     ['Ã†'] = {0xc3, 0x86},
    1     ['Ã‡'] = {0xc3, 0x87},
    1     ['Ãˆ'] = {0xc3, 0x88},
    1     ['Ã‰'] = {0xc3, 0x89},
    1     ['ÃŠ'] = {0xc3, 0x8a},
    1     ['Ã‹'] = {0xc3, 0x8b},
    1     ['ÃŒ'] = {0xc3, 0x8c},
    1     ['Ã'] = {0xc3, 0x8d},
    1     ['ÃŽ'] = {0xc3, 0x8e},
    1     ['Ã'] = {0xc3, 0x8f},
    1     ['Ã'] = {0xc3, 0x90},
    1     ['Ã‘'] = {0xc3, 0x91},
    1     ['Ã’'] = {0xc3, 0x92},
    1     ['Ã“'] = {0xc3, 0x93},
    1     ['Ã”'] = {0xc3, 0x94},
    1     ['Ã•'] = {0xc3, 0x95},
    1     ['Ã–'] = {0xc3, 0x96},
    1     ['Ã—'] = {0xc3, 0x97},
    1     ['Ã˜'] = {0xc3, 0x98},
    1     ['Ã™'] = {0xc3, 0x99},
    1     ['Ãš'] = {0xc3, 0x9a},
    1     ['Ã›'] = {0xc3, 0x9b},
    1     ['Ãœ'] = {0xc3, 0x9c},
    1     ['Ã'] = {0xc3, 0x9d},
    1     ['Ãž'] = {0xc3, 0x9e},
    1     ['ÃŸ'] = {0xc3, 0x9f},
    1     ['Ã '] = {0xc3, 0xa0},
    1     ['Ã¡'] = {0xc3, 0xa1},
    1     ['Ã¢'] = {0xc3, 0xa2},
    1     ['Ã£'] = {0xc3, 0xa3},
    1     ['Ã¤'] = {0xc3, 0xa4},
    1     ['Ã¥'] = {0xc3, 0xa5},
    1     ['Ã¦'] = {0xc3, 0xa6},
    1     ['Ã§'] = {0xc3, 0xa7},
    1     ['Ã¨'] = {0xc3, 0xa8},
    1     ['Ã©'] = {0xc3, 0xa9},
    1     ['Ãª'] = {0xc3, 0xaa},
    1     ['Ã«'] = {0xc3, 0xab},
    1     ['Ã¬'] = {0xc3, 0xac},
    1     ['Ã­'] = {0xc3, 0xad},
    1     ['Ã®'] = {0xc3, 0xae},
    1     ['Ã¯'] = {0xc3, 0xaf},
    1     ['Ã°'] = {0xc3, 0xb0},
    1     ['Ã±'] = {0xc3, 0xb1},
    1     ['Ã²'] = {0xc3, 0xb2},
    1     ['Ã³'] = {0xc3, 0xb3},
    1     ['Ã´'] = {0xc3, 0xb4},
    1     ['Ãµ'] = {0xc3, 0xb5},
    1     ['Ã¶'] = {0xc3, 0xb6},
    1     ['Ã·'] = {0xc3, 0xb7},
    1     ['Ã¸'] = {0xc3, 0xb8},
    1     ['Ã¹'] = {0xc3, 0xb9},
    1     ['Ãº'] = {0xc3, 0xba},
    1     ['Ã»'] = {0xc3, 0xbb},
    1     ['Ã¼'] = {0xc3, 0xbc},
    1     ['Ã½'] = {0xc3, 0xbd},
    1     ['Ã¾'] = {0xc3, 0xbe},
    1     ['Ã¿'] = {0xc3, 0xbf},
      }

    1 local four_byte = {
    1     ['ðŸ¤'] = {0xf0, 0x9f, 0xa4, 0x8d},
    1     ['ðŸ¤Ž'] = {0xf0, 0x9f, 0xa4, 0x8e},
    1     ['ðŸ¤'] = {0xf0, 0x9f, 0xa4, 0x8f},
    1     ['ðŸ¤'] = {0xf0, 0x9f, 0xa4, 0x90},
    1     ['ðŸ¤‘'] = {0xf0, 0x9f, 0xa4, 0x91},
    1     ['ðŸ¤’'] = {0xf0, 0x9f, 0xa4, 0x92},
    1     ['ðŸ¤“'] = {0xf0, 0x9f, 0xa4, 0x93},
    1     ['ðŸ¤”'] = {0xf0, 0x9f, 0xa4, 0x94},
    1     ['ðŸ¤•'] = {0xf0, 0x9f, 0xa4, 0x95},
    1     ['ðŸ¤–'] = {0xf0, 0x9f, 0xa4, 0x96},
    1     ['ðŸ¤—'] = {0xf0, 0x9f, 0xa4, 0x97},
    1     ['ðŸ¤˜'] = {0xf0, 0x9f, 0xa4, 0x98},
    1     ['ðŸ¤™'] = {0xf0, 0x9f, 0xa4, 0x99},
    1     ['ðŸ¤š'] = {0xf0, 0x9f, 0xa4, 0x9a},
    1     ['ðŸ¤›'] = {0xf0, 0x9f, 0xa4, 0x9b},
    1     ['ðŸ¤œ'] = {0xf0, 0x9f, 0xa4, 0x9c},
    1     ['ðŸ¤'] = {0xf0, 0x9f, 0xa4, 0x9d},
    1     ['ðŸ¤ž'] = {0xf0, 0x9f, 0xa4, 0x9e},
    1     ['ðŸ¤Ÿ'] = {0xf0, 0x9f, 0xa4, 0x9f},
    1     ['ðŸ¤ '] = {0xf0, 0x9f, 0xa4, 0xa0},
    1     ['ðŸ¤¡'] = {0xf0, 0x9f, 0xa4, 0xa1},
    1     ['ðŸ¤¢'] = {0xf0, 0x9f, 0xa4, 0xa2},
    1     ['ðŸ¤£'] = {0xf0, 0x9f, 0xa4, 0xa3},
    1     ['ðŸ¤¤'] = {0xf0, 0x9f, 0xa4, 0xa4},
    1     ['ðŸ¤¥'] = {0xf0, 0x9f, 0xa4, 0xa5},
    1     ['ðŸ¤¦'] = {0xf0, 0x9f, 0xa4, 0xa6},
    1     ['ðŸ¤§'] = {0xf0, 0x9f, 0xa4, 0xa7},
    1     ['ðŸ¤¨'] = {0xf0, 0x9f, 0xa4, 0xa8},
    1     ['ðŸ¤©'] = {0xf0, 0x9f, 0xa4, 0xa9},
    1     ['ðŸ¤ª'] = {0xf0, 0x9f, 0xa4, 0xaa},
    1     ['ðŸ¤«'] = {0xf0, 0x9f, 0xa4, 0xab},
    1     ['ðŸ¤¬'] = {0xf0, 0x9f, 0xa4, 0xac},
    1     ['ðŸ¤­'] = {0xf0, 0x9f, 0xa4, 0xad},
    1     ['ðŸ¤®'] = {0xf0, 0x9f, 0xa4, 0xae},
    1     ['ðŸ¤¯'] = {0xf0, 0x9f, 0xa4, 0xaf},
    1     ['ðŸ¤°'] = {0xf0, 0x9f, 0xa4, 0xb0},
    1     ['ðŸ¤±'] = {0xf0, 0x9f, 0xa4, 0xb1},
    1     ['ðŸ¤²'] = {0xf0, 0x9f, 0xa4, 0xb2},
    1     ['ðŸ¤³'] = {0xf0, 0x9f, 0xa4, 0xb3},
    1     ['ðŸ¤´'] = {0xf0, 0x9f, 0xa4, 0xb4},
    1     ['ðŸ¤µ'] = {0xf0, 0x9f, 0xa4, 0xb5},
    1     ['ðŸ¤¶'] = {0xf0, 0x9f, 0xa4, 0xb6},
    1     ['ðŸ¤·'] = {0xf0, 0x9f, 0xa4, 0xb7},
    1     ['ðŸ¤¸'] = {0xf0, 0x9f, 0xa4, 0xb8},
    1     ['ðŸ¤¹'] = {0xf0, 0x9f, 0xa4, 0xb9},
    1     ['ðŸ¤º'] = {0xf0, 0x9f, 0xa4, 0xba},
    1     ['ðŸ¤¼'] = {0xf0, 0x9f, 0xa4, 0xbc},
    1     ['ðŸ¤½'] = {0xf0, 0x9f, 0xa4, 0xbd},
    1     ['ðŸ¤¾'] = {0xf0, 0x9f, 0xa4, 0xbe},
    1     ['ðŸ¤¿'] = {0xf0, 0x9f, 0xa4, 0xbf},
    1     ['ðŸ¥€'] = {0xf0, 0x9f, 0xa5, 0x80},
    1     ['ðŸ¥'] = {0xf0, 0x9f, 0xa5, 0x81},
    1     ['ðŸ¥‚'] = {0xf0, 0x9f, 0xa5, 0x82},
    1     ['ðŸ¥ƒ'] = {0xf0, 0x9f, 0xa5, 0x83},
    1     ['ðŸ¥„'] = {0xf0, 0x9f, 0xa5, 0x84},
    1     ['ðŸ¥…'] = {0xf0, 0x9f, 0xa5, 0x85},
    1     ['ðŸ¥‡'] = {0xf0, 0x9f, 0xa5, 0x87},
    1     ['ðŸ¥ˆ'] = {0xf0, 0x9f, 0xa5, 0x88},
    1     ['ðŸ¥‰'] = {0xf0, 0x9f, 0xa5, 0x89},
    1     ['ðŸ¥Š'] = {0xf0, 0x9f, 0xa5, 0x8a},
    1     ['ðŸ¥‹'] = {0xf0, 0x9f, 0xa5, 0x8b},
    1     ['ðŸ¥Œ'] = {0xf0, 0x9f, 0xa5, 0x8c},
    1     ['ðŸ¥'] = {0xf0, 0x9f, 0xa5, 0x8d},
    1     ['ðŸ¥Ž'] = {0xf0, 0x9f, 0xa5, 0x8e},
    1     ['ðŸ¥'] = {0xf0, 0x9f, 0xa5, 0x8f},
    1     ['ðŸ¥'] = {0xf0, 0x9f, 0xa5, 0x90},
    1     ['ðŸ¥‘'] = {0xf0, 0x9f, 0xa5, 0x91},
    1     ['ðŸ¥’'] = {0xf0, 0x9f, 0xa5, 0x92},
    1     ['ðŸ¥“'] = {0xf0, 0x9f, 0xa5, 0x93},
    1     ['ðŸ¥”'] = {0xf0, 0x9f, 0xa5, 0x94},
    1     ['ðŸ¥•'] = {0xf0, 0x9f, 0xa5, 0x95},
    1     ['ðŸ¥–'] = {0xf0, 0x9f, 0xa5, 0x96},
    1     ['ðŸ¥—'] = {0xf0, 0x9f, 0xa5, 0x97},
    1     ['ðŸ¥˜'] = {0xf0, 0x9f, 0xa5, 0x98},
    1     ['ðŸ¥™'] = {0xf0, 0x9f, 0xa5, 0x99},
    1     ['ðŸ¥š'] = {0xf0, 0x9f, 0xa5, 0x9a},
    1     ['ðŸ¥›'] = {0xf0, 0x9f, 0xa5, 0x9b},
    1     ['ðŸ¥œ'] = {0xf0, 0x9f, 0xa5, 0x9c},
    1     ['ðŸ¥'] = {0xf0, 0x9f, 0xa5, 0x9d},
    1     ['ðŸ¥ž'] = {0xf0, 0x9f, 0xa5, 0x9e},
    1     ['ðŸ¥Ÿ'] = {0xf0, 0x9f, 0xa5, 0x9f},
    1     ['ðŸ¥ '] = {0xf0, 0x9f, 0xa5, 0xa0},
    1     ['ðŸ¥¡'] = {0xf0, 0x9f, 0xa5, 0xa1},
    1     ['ðŸ¥¢'] = {0xf0, 0x9f, 0xa5, 0xa2},
    1     ['ðŸ¥£'] = {0xf0, 0x9f, 0xa5, 0xa3},
    1     ['ðŸ¥¤'] = {0xf0, 0x9f, 0xa5, 0xa4},
    1     ['ðŸ¥¥'] = {0xf0, 0x9f, 0xa5, 0xa5},
    1     ['ðŸ¥¦'] = {0xf0, 0x9f, 0xa5, 0xa6},
    1     ['ðŸ¥§'] = {0xf0, 0x9f, 0xa5, 0xa7},
    1     ['ðŸ¥¨'] = {0xf0, 0x9f, 0xa5, 0xa8},
    1     ['ðŸ¥©'] = {0xf0, 0x9f, 0xa5, 0xa9},
    1     ['ðŸ¥ª'] = {0xf0, 0x9f, 0xa5, 0xaa},
    1     ['ðŸ¥«'] = {0xf0, 0x9f, 0xa5, 0xab},
    1     ['ðŸ¥¬'] = {0xf0, 0x9f, 0xa5, 0xac},
    1     ['ðŸ¥­'] = {0xf0, 0x9f, 0xa5, 0xad},
    1     ['ðŸ¥®'] = {0xf0, 0x9f, 0xa5, 0xae},
    1     ['ðŸ¥¯'] = {0xf0, 0x9f, 0xa5, 0xaf},
    1     ['ðŸ¥°'] = {0xf0, 0x9f, 0xa5, 0xb0},
    1     ['ðŸ¥±'] = {0xf0, 0x9f, 0xa5, 0xb1},
    1     ['ðŸ¥³'] = {0xf0, 0x9f, 0xa5, 0xb3},
    1     ['ðŸ¥´'] = {0xf0, 0x9f, 0xa5, 0xb4},
    1     ['ðŸ¥µ'] = {0xf0, 0x9f, 0xa5, 0xb5},
    1     ['ðŸ¥¶'] = {0xf0, 0x9f, 0xa5, 0xb6},
    1     ['ðŸ¥º'] = {0xf0, 0x9f, 0xa5, 0xba},
    1     ['ðŸ¥»'] = {0xf0, 0x9f, 0xa5, 0xbb},
    1     ['ðŸ¥¼'] = {0xf0, 0x9f, 0xa5, 0xbc},
    1     ['ðŸ¥½'] = {0xf0, 0x9f, 0xa5, 0xbd},
    1     ['ðŸ¥¾'] = {0xf0, 0x9f, 0xa5, 0xbe},
    1     ['ðŸ¥¿'] = {0xf0, 0x9f, 0xa5, 0xbf},
    1     ['ðŸ¦€'] = {0xf0, 0x9f, 0xa6, 0x80},
    1     ['ðŸ¦'] = {0xf0, 0x9f, 0xa6, 0x81},
    1     ['ðŸ¦‚'] = {0xf0, 0x9f, 0xa6, 0x82},
    1     ['ðŸ¦ƒ'] = {0xf0, 0x9f, 0xa6, 0x83},
    1     ['ðŸ¦„'] = {0xf0, 0x9f, 0xa6, 0x84},
    1     ['ðŸ¦…'] = {0xf0, 0x9f, 0xa6, 0x85},
    1     ['ðŸ¦†'] = {0xf0, 0x9f, 0xa6, 0x86},
    1     ['ðŸ¦‡'] = {0xf0, 0x9f, 0xa6, 0x87},
    1     ['ðŸ¦ˆ'] = {0xf0, 0x9f, 0xa6, 0x88},
    1     ['ðŸ¦‰'] = {0xf0, 0x9f, 0xa6, 0x89},
    1     ['ðŸ¦Š'] = {0xf0, 0x9f, 0xa6, 0x8a},
    1     ['ðŸ¦‹'] = {0xf0, 0x9f, 0xa6, 0x8b},
    1     ['ðŸ¦Œ'] = {0xf0, 0x9f, 0xa6, 0x8c},
    1     ['ðŸ¦'] = {0xf0, 0x9f, 0xa6, 0x8d},
    1     ['ðŸ¦Ž'] = {0xf0, 0x9f, 0xa6, 0x8e},
    1     ['ðŸ¦'] = {0xf0, 0x9f, 0xa6, 0x8f},
    1     ['ðŸ¦'] = {0xf0, 0x9f, 0xa6, 0x90},
    1     ['ðŸ¦‘'] = {0xf0, 0x9f, 0xa6, 0x91},
    1     ['ðŸ¦’'] = {0xf0, 0x9f, 0xa6, 0x92},
    1     ['ðŸ¦“'] = {0xf0, 0x9f, 0xa6, 0x93},
    1     ['ðŸ¦”'] = {0xf0, 0x9f, 0xa6, 0x94},
    1     ['ðŸ¦•'] = {0xf0, 0x9f, 0xa6, 0x95},
    1     ['ðŸ¦–'] = {0xf0, 0x9f, 0xa6, 0x96},
    1     ['ðŸ¦—'] = {0xf0, 0x9f, 0xa6, 0x97},
    1     ['ðŸ¦˜'] = {0xf0, 0x9f, 0xa6, 0x98},
    1     ['ðŸ¦™'] = {0xf0, 0x9f, 0xa6, 0x99},
    1     ['ðŸ¦š'] = {0xf0, 0x9f, 0xa6, 0x9a},
    1     ['ðŸ¦›'] = {0xf0, 0x9f, 0xa6, 0x9b},
    1     ['ðŸ¦œ'] = {0xf0, 0x9f, 0xa6, 0x9c},
    1     ['ðŸ¦'] = {0xf0, 0x9f, 0xa6, 0x9d},
    1     ['ðŸ¦ž'] = {0xf0, 0x9f, 0xa6, 0x9e},
    1     ['ðŸ¦Ÿ'] = {0xf0, 0x9f, 0xa6, 0x9f},
    1     ['ðŸ¦ '] = {0xf0, 0x9f, 0xa6, 0xa0},
    1     ['ðŸ¦¡'] = {0xf0, 0x9f, 0xa6, 0xa1},
    1     ['ðŸ¦¢'] = {0xf0, 0x9f, 0xa6, 0xa2},
    1     ['ðŸ¦¥'] = {0xf0, 0x9f, 0xa6, 0xa5},
    1     ['ðŸ¦¦'] = {0xf0, 0x9f, 0xa6, 0xa6},
    1     ['ðŸ¦§'] = {0xf0, 0x9f, 0xa6, 0xa7},
    1     ['ðŸ¦¨'] = {0xf0, 0x9f, 0xa6, 0xa8},
    1     ['ðŸ¦©'] = {0xf0, 0x9f, 0xa6, 0xa9},
    1     ['ðŸ¦ª'] = {0xf0, 0x9f, 0xa6, 0xaa},
    1     ['ðŸ¦®'] = {0xf0, 0x9f, 0xa6, 0xae},
    1     ['ðŸ¦¯'] = {0xf0, 0x9f, 0xa6, 0xaf},
    1     ['ðŸ¦°'] = {0xf0, 0x9f, 0xa6, 0xb0},
    1     ['ðŸ¦±'] = {0xf0, 0x9f, 0xa6, 0xb1},
    1     ['ðŸ¦²'] = {0xf0, 0x9f, 0xa6, 0xb2},
    1     ['ðŸ¦³'] = {0xf0, 0x9f, 0xa6, 0xb3},
    1     ['ðŸ¦´'] = {0xf0, 0x9f, 0xa6, 0xb4},
    1     ['ðŸ¦µ'] = {0xf0, 0x9f, 0xa6, 0xb5},
    1     ['ðŸ¦¶'] = {0xf0, 0x9f, 0xa6, 0xb6},
    1     ['ðŸ¦·'] = {0xf0, 0x9f, 0xa6, 0xb7},
    1     ['ðŸ¦¸'] = {0xf0, 0x9f, 0xa6, 0xb8},
    1     ['ðŸ¦¹'] = {0xf0, 0x9f, 0xa6, 0xb9},
    1     ['ðŸ¦º'] = {0xf0, 0x9f, 0xa6, 0xba},
    1     ['ðŸ¦»'] = {0xf0, 0x9f, 0xa6, 0xbb},
    1     ['ðŸ¦¼'] = {0xf0, 0x9f, 0xa6, 0xbc},
    1     ['ðŸ¦½'] = {0xf0, 0x9f, 0xa6, 0xbd},
    1     ['ðŸ¦¾'] = {0xf0, 0x9f, 0xa6, 0xbe},
    1     ['ðŸ¦¿'] = {0xf0, 0x9f, 0xa6, 0xbf},
    1     ['ðŸ§€'] = {0xf0, 0x9f, 0xa7, 0x80},
    1     ['ðŸ§'] = {0xf0, 0x9f, 0xa7, 0x81},
    1     ['ðŸ§‚'] = {0xf0, 0x9f, 0xa7, 0x82},
    1     ['ðŸ§ƒ'] = {0xf0, 0x9f, 0xa7, 0x83},
    1     ['ðŸ§„'] = {0xf0, 0x9f, 0xa7, 0x84},
    1     ['ðŸ§…'] = {0xf0, 0x9f, 0xa7, 0x85},
    1     ['ðŸ§†'] = {0xf0, 0x9f, 0xa7, 0x86},
    1     ['ðŸ§‡'] = {0xf0, 0x9f, 0xa7, 0x87},
    1     ['ðŸ§ˆ'] = {0xf0, 0x9f, 0xa7, 0x88},
    1     ['ðŸ§‰'] = {0xf0, 0x9f, 0xa7, 0x89},
    1     ['ðŸ§Š'] = {0xf0, 0x9f, 0xa7, 0x8a},
    1     ['ðŸ§'] = {0xf0, 0x9f, 0xa7, 0x8d},
    1     ['ðŸ§Ž'] = {0xf0, 0x9f, 0xa7, 0x8e},
    1     ['ðŸ§'] = {0xf0, 0x9f, 0xa7, 0x8f},
    1     ['ðŸ§'] = {0xf0, 0x9f, 0xa7, 0x90},
    1     ['ðŸ§‘'] = {0xf0, 0x9f, 0xa7, 0x91},
    1     ['ðŸ§’'] = {0xf0, 0x9f, 0xa7, 0x92},
    1     ['ðŸ§“'] = {0xf0, 0x9f, 0xa7, 0x93},
    1     ['ðŸ§”'] = {0xf0, 0x9f, 0xa7, 0x94},
    1     ['ðŸ§•'] = {0xf0, 0x9f, 0xa7, 0x95},
    1     ['ðŸ§–'] = {0xf0, 0x9f, 0xa7, 0x96},
    1     ['ðŸ§—'] = {0xf0, 0x9f, 0xa7, 0x97},
    1     ['ðŸ§˜'] = {0xf0, 0x9f, 0xa7, 0x98},
    1     ['ðŸ§™'] = {0xf0, 0x9f, 0xa7, 0x99},
    1     ['ðŸ§š'] = {0xf0, 0x9f, 0xa7, 0x9a},
    1     ['ðŸ§›'] = {0xf0, 0x9f, 0xa7, 0x9b},
    1     ['ðŸ§œ'] = {0xf0, 0x9f, 0xa7, 0x9c},
    1     ['ðŸ§'] = {0xf0, 0x9f, 0xa7, 0x9d},
    1     ['ðŸ§ž'] = {0xf0, 0x9f, 0xa7, 0x9e},
    1     ['ðŸ§Ÿ'] = {0xf0, 0x9f, 0xa7, 0x9f},
    1     ['ðŸ§ '] = {0xf0, 0x9f, 0xa7, 0xa0},
    1     ['ðŸ§¡'] = {0xf0, 0x9f, 0xa7, 0xa1},
    1     ['ðŸ§¢'] = {0xf0, 0x9f, 0xa7, 0xa2},
    1     ['ðŸ§£'] = {0xf0, 0x9f, 0xa7, 0xa3},
    1     ['ðŸ§¤'] = {0xf0, 0x9f, 0xa7, 0xa4},
    1     ['ðŸ§¥'] = {0xf0, 0x9f, 0xa7, 0xa5},
    1     ['ðŸ§¦'] = {0xf0, 0x9f, 0xa7, 0xa6},
    1     ['ðŸ§§'] = {0xf0, 0x9f, 0xa7, 0xa7},
    1     ['ðŸ§¨'] = {0xf0, 0x9f, 0xa7, 0xa8},
    1     ['ðŸ§©'] = {0xf0, 0x9f, 0xa7, 0xa9},
    1     ['ðŸ§ª'] = {0xf0, 0x9f, 0xa7, 0xaa},
    1     ['ðŸ§«'] = {0xf0, 0x9f, 0xa7, 0xab},
    1     ['ðŸ§¬'] = {0xf0, 0x9f, 0xa7, 0xac},
    1     ['ðŸ§­'] = {0xf0, 0x9f, 0xa7, 0xad},
    1     ['ðŸ§®'] = {0xf0, 0x9f, 0xa7, 0xae},
    1     ['ðŸ§¯'] = {0xf0, 0x9f, 0xa7, 0xaf},
    1     ['ðŸ§°'] = {0xf0, 0x9f, 0xa7, 0xb0},
    1     ['ðŸ§±'] = {0xf0, 0x9f, 0xa7, 0xb1},
    1     ['ðŸ§²'] = {0xf0, 0x9f, 0xa7, 0xb2},
    1     ['ðŸ§³'] = {0xf0, 0x9f, 0xa7, 0xb3},
    1     ['ðŸ§´'] = {0xf0, 0x9f, 0xa7, 0xb4},
    1     ['ðŸ§µ'] = {0xf0, 0x9f, 0xa7, 0xb5},
    1     ['ðŸ§¶'] = {0xf0, 0x9f, 0xa7, 0xb6},
    1     ['ðŸ§·'] = {0xf0, 0x9f, 0xa7, 0xb7},
    1     ['ðŸ§¸'] = {0xf0, 0x9f, 0xa7, 0xb8},
    1     ['ðŸ§¹'] = {0xf0, 0x9f, 0xa7, 0xb9},
    1     ['ðŸ§º'] = {0xf0, 0x9f, 0xa7, 0xba},
    1     ['ðŸ§»'] = {0xf0, 0x9f, 0xa7, 0xbb},
    1     ['ðŸ§¼'] = {0xf0, 0x9f, 0xa7, 0xbc},
    1     ['ðŸ§½'] = {0xf0, 0x9f, 0xa7, 0xbd},
    1     ['ðŸ§¾'] = {0xf0, 0x9f, 0xa7, 0xbe},
    1     ['ðŸ§¿'] = {0xf0, 0x9f, 0xa7, 0xbf},
      }

    1 return {
    1     four_byte = four_byte,
    1     three_byte = three_byte,
    1     two_byte = two_byte,
    1 }

==============================================================================
./xml-puller.lua
==============================================================================
    1 local event = require 'event'
    1 local Buffer = require 'buffer'


    1 local Puller = {}


    1 Puller.__index = Puller

    1 local state = {
    1     declaration = 'Declaration',
    1     after_declaration = 'AfterDeclaration',
    1     doctype = 'Doctype',
    1     after_doctype = 'AfterDoctype',
    1     elements = 'Elements',
    1     attributes = 'Attributes',
    1     after_elements = 'AfterElements',
    1     done = 'End',
      }

      --- parse any number of letters, numbers, periods
      --- underscores followed by a single `-` recursivly
    1 function Puller:_parse_encoding_trailer()
    3     local s = self:eat('[a-zA-Z0-9._]*')
    3     local s2 = self:eat('-') or ''
    3     if not s or s == '' and not s2 then return '' end
    2     if not s2 then return s end
    2     if not s or s == '' then return s2 end
    2     return s .. s2 .. self:_parse_encoding_trailer()
      end

    1 function Puller:_parse_decl()
    1     self:_advancebuffer(6)
    1     self:_skip_whitespace()
    1     if not self:eat('version') then
****0         return nil, 'expected `version`'
          end
    1     if not self:eat('=') then
****0         return nil, 'expected = found ' .. string.char(self.buffer:current_byte())
          end
    1     local q = self:eat('\'') or self:eat('"')
    1     if not q then
****0         return nil, 'version must be quoted ' .. string.char(self.buffer:current_byte())
          end
    1     local v = self.buffer:consume_str('1%.%d+')
    1     if not v then
****0         return nil, 'expected version number'
          end
    1     self:eat(q)
    1     self:_skip_whitespace()
          local encoding
    1     if self:eat('encoding') then
    1         self:_parse_eq()
    1         local q2 = self:_parse_quote()
              local e
    1         encoding, e = self:eat('[a-zA-Z]')
    1         if not encoding then
****0             return nil, e
              end
    1         encoding = encoding .. self:_parse_encoding_trailer()
    1         self:_parse_quote(q2)
    1         self:_skip_whitespace()
          end
          local standalone
    1     if self:eat('standalone') then
    1         self:_parse_eq()
    1         local q3 = self:_parse_quote()
    1         if self:eat('yes') then
****0             standalone = true
    1         elseif self:eat('no') then
    1             standalone = false
              end
    1         if standalone == nil then
****0             return nil, 'Invalid value for standalone'
              end
    1         self:eat(q3)
          end
    1     self:_skip_whitespace()
    1     self:eat('%?>')
    1     return event.Event.decl(v, encoding, standalone)
      end

    1 function Puller:parse_doctype()
    4     self.buffer:advance(9)
    4     self:_skip_whitespace()
    4     local name = self:_eat_name()
    4     self:_skip_whitespace()
          local external_id, lit1, lit2
    4     if self.buffer:starts_with('SYSTEM') or self.buffer:starts_with('PUBLIC') then
    2         external_id, lit1, lit2 = self:parse_external_id()
          end
    4     self:_skip_whitespace()
    4     local current_char = self.buffer:current_char()
    4     if current_char ~= '>' and current_char ~= '[' then
****0         return nil, 'Expected > or [ in doctype found ' .. current_char
          end
    4     self.buffer:advance(1)
    4     local external_value = {}
    4     if not lit1 and not lit2 then
    2         external_value = nil
    2         external_value = {lit1, lit2}
          end
    4     if lit1 then table.insert(external_value, lit1) end
    4     if lit2 then table.insert(external_value, lit2) end
    4     if current_char == '[' then
    2         return event.Event.doctype_start(name, external_id, external_value)
          end
    2     return event.Event.empty_doctype(name, external_id, external_value)
      end

    1 function Puller:parse_comment()
    1     self.buffer:advance(4)
    1     local content = self.buffer:consume_until('-->')
    1     self.buffer:advance(3)
    1     return event.Event.comment(content)
      end

    1 function Puller:parse_pi()
    2     self.buffer:advance(2)
    2     local target = self:_eat_name()
    2     self:_skip_whitespace()
    2     local content = self.buffer:consume_until('?>')
    2     if content == '' then
    1         content = nil
          end
    2     self.buffer:advance(2)
    2     return event.Event.pi(target, content)
      end

    1 function Puller:parse_entity_decl()
    3     self:_advancebuffer(8)
    3     self:_skip_whitespace()
    3     local is_ge = true
    3     if self.buffer:starts_with('%%') then
****0         self:_advancebuffer(1)
****0         self:_skip_whitespace()
****0         is_ge = false
          end
    3     local name = self:_eat_name()
    3     self:_skip_whitespace()
    3     local def = self:parse_entity_def(is_ge)
    3     self:_skip_whitespace()
    3     if not self.buffer:starts_with('>') then
****0         return nil, string.format('expected > found %s', self.buffer:current_char())
          end
    3     self:_advancebuffer(1) -- >
    3     return event.Event.entity_declaration(name, def.ext_id, def.ext_val, def.ndata)
      end

    1 function Puller:parse_entity_def(is_ge)
    3     local c = self.buffer:current_char()
    3     if c == '"' or c == '\'' then
    1         self:_parse_quote(c)
              
    7         local contents = self.buffer:consume_while(function (ch) return ch ~= c end)
    1         self:_parse_quote(c)
    1         return {
    1             ext_val = contents,
    1         }
    2     elseif c == 'S' or c == 'P' then
    2         local id, lit1, lit2 = self:parse_external_id()
              
    2         if id == nil then
****0             return nil, lit1 --error here
              end
    2         local ret = {
    2             ext_id = id,
    2             ext_val = {lit1, lit2},
    2             ndata = nil,
              }
    2         if is_ge then
    2             self:_skip_whitespace()
    2             if self.buffer:starts_with("NDATA") then
****0                 self:_advancebuffer(5)
****0                 self:_skip_whitespace()
****0                 local name = self:_eat_name()
****0                 ret.ndata = name
                  end
              end
    2         return ret
          else
****0         return nil, string.format('Expected quote or SYSTEM or PUBLIC found "%s"', self.buffer:current_char())
          end
      end

    1 function Puller:parse_element_start()
    1     self.buffer:advance(1) -- <
    1     local prefix, name = self:_eat_qname()
    1     if prefix == nil then
****0         return nil, name --error here
          end
    1     if name == nil then
    1         return event.Event.open_tag(nil, prefix)
          end
****0     return event.Event.open_tag(prefix, name)
      end

    1 function Puller:parse_close_element()
    1     self:_advancebuffer(2) -- </
    1     local prefix, name = self:_eat_qname()
    1     if prefix == nil then
****0         return nil, name --error
          end
    1     self:_skip_whitespace()
    1     if not self:eat('>') then
****0         return nil, string.format('expected `>` found %s', self.buffer:current_char())
          end
    1     if name == nil then
    1         return event.Event.close_tag(nil, prefix)
          end
****0     return event.Event.close_tag(prefix, name)
      end

    1 function Puller:parse_attribute()
    1     if self.buffer:starts_with('/>') then
****0         self:_advancebuffer(2)
****0         return event.Event.tag_end(true)
    1     elseif self.buffer:starts_with('>') then
    1         self:_advancebuffer(1)
    1         return event.Event.tag_end(false)
          end
****0     local prefix, name = self:_eat_qname()
****0     if prefix == nil then
****0         return nil, name --error here
          end
****0     local eq = self:eat('=')
****0     if eq == nil then
****0         return nil, string.format('expected = found %s', self.buffer:current_char())
          end
****0     local quote = self:_parse_quote()
****0     local value = self.buffer:consume_while(function (c) return c ~= quote and c ~= '<' end)
****0     if not self:_parse_quote(quote) then
****0         return nil, string.format('Invalid attribute value, expecting %s found %s', quote, self.buffer:current_char())
          end
****0     if name == nil then
****0         return event.Event.attr(
****0             nil, name, value
              )
          end
****0     return event.Event.attr(prefix, name, value)
      end

    1 function Puller:parse_text()
****0     local text, err = self.buffer:consume_until('<')
****0     if text == nil then
****0         return nil, err
          end
****0     if string.find(text, "]]>", nil, true) then
****0         return nil, 'Invalid text node, cannot contain `]]>`'
          end
****0     return text
      end

    1 function Puller:parse_cdata()
    1     self:_advancebuffer(9) --<![CDATA[
    1     local text = self.buffer:consume_until(']]>')
    1     self:_advancebuffer(3)
    1     return event.Event.cdata(text)
      end

    1 function Puller:parse_external_id()
    4     if not self.buffer:starts_with('SYSTEM') and not self.buffer:starts_with('PUBLIC') then
****0         return nil, 'Invalid external id, expected SYSTEM or PUBLIC'
          end
    4     local id = self.buffer:advance(6)
    4     self:_skip_whitespace()
    4     local q = self:_parse_quote()
   55     local lit1 = self.buffer:consume_while(function(s) return s ~= q end)
    4     self:_parse_quote(q)
    4     if id == 'SYSTEM' then
    2         return id, lit1
          else
    2         self:_skip_whitespace()
    2         local q2 = self:_parse_quote()
   29         local lit2 = self.buffer:consume_while(function(s) return s ~= q end)
    2         self:_parse_quote(q2)
    2         return id, lit1, lit2
          end
      end

    1 function Puller:_parse_quote(q)
   17     local q = q or '["\']'
   17     local ret = self:eat(q)
   17     assert(ret, string.format('expected %s found: %s', q or '" or \'', self.buffer:current_char()))
   17     return ret
      end

    1 function Puller:_parse_eq()
    2     return assert(self:eat('='), 'expected equal sign')
      end


    1 function Puller:_eat_name()
   11     local at_start, len = self:_at_name_start()
   11     if not at_start then
****0         print(debug.traceback())
          end
   11     assert(at_start, string.format('Invalid name start `%s`', string.sub(self.buffer.stream, self.buffer.current_idx)))
   11     local ret = self.buffer:advance(len)
   11     local at_continue, len = self:_at_name_cont()
   44     while at_continue do
   33         ret = ret .. self.buffer:advance(len)
   33         at_continue, len = self:_at_name_cont()
          end
   11     return ret
      end

    1 function Puller:_eat_qname()
    2     local first = self:_eat_name()
          local second
    2     if self.buffer:starts_with(':') then
****0         self:_advancebuffer(1)
****0         second = self:_eat_name()
          end
    2     if self.buffer:starts_with(':') then
****0         return nil, string.format('Invalid name, only one prefix allowed @ %s', self.current_idx)
          end
    2     return first, second
      end

    1 function Puller:_at_name_start()
   11     if self.buffer:starts_with('[a-zA-Z:_]') then
   11         return true, 1
          end

****0     local ch, len = self.buffer:next_utf8_int()

****0     return ((ch >= 0x0000C0 and ch <= 0x0000D6)
****0         or (ch >= 0x0000D8 and ch <= 0x0000F6)
****0         or (ch >= 0x0000F8 and ch <= 0x0002FF)
****0         or (ch >= 0x000370 and ch <= 0x00037D)
****0         or (ch >= 0x00037F and ch <= 0x001FFF)
****0         or (ch >= 0x00200C and ch <= 0x00200D)
****0         or (ch >= 0x002070 and ch <= 0x00218F)
****0         or (ch >= 0x002C00 and ch <= 0x002FEF)
****0         or (ch >= 0x003001 and ch <= 0x00D7FF)
****0         or (ch >= 0x00F900 and ch <= 0x00FDCF)
****0         or (ch >= 0x00FDF0 and ch <= 0x00FFFD)
****0         or (ch >= 0x010000 and ch <= 0x0EFFFF)), len
      end

    1 function Puller:_at_name_cont()
   44     if self.buffer:starts_with('[a-zA-Z0-9:_%-%.]') then
   33         return true, 1
          end
   11     local ch, len = self.buffer:next_utf8_int()
   11     return (ch == 0x0000B7
   11         or (ch >= 0x0000C0 and ch <= 0x0000D6)
   11         or (ch >= 0x0000D8 and ch <= 0x0000F6)
   11         or (ch >= 0x0000F8 and ch <= 0x0002FF)
   11         or (ch >= 0x000300 and ch <= 0x00036F)
   11         or (ch >= 0x000370 and ch <= 0x00037D)
   11         or (ch >= 0x00037F and ch <= 0x001FFF)
   11         or (ch >= 0x00200C and ch <= 0x00200D)
   11         or (ch >= 0x00203F and ch <= 0x002040)
   11         or (ch >= 0x002070 and ch <= 0x00218F)
   11         or (ch >= 0x002C00 and ch <= 0x002FEF)
   11         or (ch >= 0x003001 and ch <= 0x00D7FF)
   11         or (ch >= 0x00F900 and ch <= 0x00FDCF)
   11         or (ch >= 0x00FDF0 and ch <= 0x00FFFD)
   11         or (ch >= 0x010000 and ch <= 0x0EFFFF)), len
      end

    1 function Puller:_parse_name_cont()
****0     return assert(self:eat('[]+'))
      end

    1 function Puller.new(buffer, buffer_is_fragment)
    9     local st = state.declaration
    9     if buffer_is_fragment then
****0         st = state.elements
          end
    9     local ret = {
              ---@type string
    9         buffer = Buffer.new(buffer),
    9         depth = 0,
    9         state = st,
          }
    9     setmetatable(ret, Puller)
    9     return ret
      end

    1 function Puller:eat(s)
   38     return self.buffer:consume_str(s)
      end

    1 function Puller:_advancebuffer(ct)
   13     return self.buffer:advance(ct)
      end

    1 function Puller:_skip_whitespace()
   62     return self.buffer:skip_whitespace()
      end

    1 function Puller:_complete_string(quote)
****0     local after = string.sub(self.buffer, 2)
****0     local _, end_idx = string.find(after, quote)
****0     return string.sub(self.buffer, 1, end_idx)
      end

      ---Fetch the next full block of non-whitespace
    1 function Puller:_next_block(target_end)
****0     target_end = target_end or "^[^%s]+"
          -- Look ahead 1 char to see if we are starting
          -- a string because that would mean we need to look
          -- for the companion quote symbol and not whitespace
          -- as the terminator of the block
****0     local next_char = string.sub(self.buffer, 1, 2);
****0     if next_char == '"' or next_char == '\'' then
****0         local s = self:_complete_string(next_char)
****0         self:_advancebuffer(#s)
****0         return s
          else
****0         local s = string.match(self.buffer, "^[^%s]+")
****0         self:_advancebuffer(#s)
****0         return s
          end
      end

      ---Consume until the next `>`
      ---@return boolean
      ---@return string|nil
    1 function Puller:_consume_decl()
****0     local _, err = self.buffer:consume_until('>')
****0     if err ~= nil then
****0         return false, err
          end
****0     self:_advancebuffer(1)
****0     return true
      end

    1 function Puller:next()
          --- xml decl has to be the absolute first thing in the document
   25     if self:_skip_whitespace() and self.state == state.declaration then
****0         self.state = state.after_declaration
          end
   25     if self.state == state.declaration then
    9         self.state = state.after_declaration
    9         if self.buffer:starts_with('<%?xml') then
    1             return self:_parse_decl(self)
              else
    8             return self:next()
              end
   16     elseif self.state == state.after_declaration then
    8         if self.buffer:starts_with('<!DOCTYPE') then
    4             local tok, err = self:parse_doctype()
    4             if not tok then
****0                 return tok, err
                  end
    4             if tok.ty == event.event_type.doctype then
    2                 self.state = state.after_doctype
    2             elseif tok.ty == event.event_type.doctype_start then
    2                 self.state = state.doctype
                  else
****0                 return nil, 'Invalid doctype'
                  end
    4             return tok, err
    4         elseif self.buffer:starts_with('<!--') then
    1             return self:parse_comment()
    3         elseif self.buffer:starts_with('<%?') then
    2             if self.buffer:starts_with('<?xml') then
****0                 return nil, string.format('Invalid decl @ %s', self.current_idx)
                  end
    2             return self:parse_pi()
              else
    1             self.state = state.after_doctype
    1             return self:next()
              end
    8     elseif self.state == state.doctype then
    4         if self.buffer:starts_with('<!ENTITY') then
    3             return self:parse_entity_decl()
    1         elseif self.buffer:starts_with('<!--') then
****0             return self:parse_comment()
    1         elseif self.buffer:starts_with('<%?') then
****0             if self.buffer:starts_with('<%?xml') then
****0                 return nil, string.format('Invalid doctype @ %s', self.current_idx)
                  else
****0                 self:parse_pi()
                  end
    1         elseif self.buffer:starts_with(']') then
    1             self:_advancebuffer(1)
    1             self:_skip_whitespace()
    1             local current = self.buffer:current_char()
    1             if current == '>' then
    1                 self.state = state.after_doctype
    1                 self:_advancebuffer(1)
    1                 return event.Event.doctype_end()
****0             elseif current == nil then
****0                 return nil, 'Unexpected EOF'
                  else
                  end
****0         elseif self.buffer:starts_wth("<!ELEMENT") or self.buffer:starts_with("<!ATTLIST") or self.buffer:starts_with("<!NOTATION") then
                  --TODO: these should be usable?
****0             local success, err = self:_consume_decl()
****0             if success then
****0                 return self:next()
                  else
****0                 return nil, err
                  end
              end
    4     elseif self.state == state.after_doctype then
    1         if self.buffer:starts_with('<!--') then
****0             return self:parse_comment()
    1         elseif self.buffer:starts_with('<!') then
****0             return nil, string.format('Unexpected token <! not followed by -- @ %s', self.current_idx)
    1         elseif self.buffer:starts_with('<') then
    1             self.state = state.attributes
    1             return self:parse_element_start()
              end
    3     elseif self.state == state.elements then
    2         if self.buffer:starts_with('<!--') then
****0             return self:parse_comment()
    2         elseif self.buffer:at_cdata_start() then
    1             return self:parse_cdata()
    1         elseif self.buffer:starts_with('<%?xml') then
****0             return nil, 'Invalid declaration @' .. self.current_idx
    1         elseif self.buffer:starts_with('<%?') then
****0             return self:parse_pi()
    1         elseif self.buffer:starts_with('</') then
    1             if self.depth > 0 then
    1                 self.depth = self.depth - 1
                  end
    1             if self.depth == 0 and not self.fragment_parsing then
    1                 self.state = state.after_elements
                  else
****0                 self.state = state.elements
                  end
    1             return self:parse_close_element()
****0         elseif self.buffer:starts_with('<') then
****0             self.state = state.attributes
****0             return self:parse_element_start()
              else
****0             return self:parse_text()
              end
    1     elseif self.state == state.attributes then
    1         local ev, err = self:parse_attribute()
    1         if ev == nil then
****0             return nil, err
              end
    1         if ev.ty == event.event_type.tag_end then
    1             if not ev.is_empty then
    1                 self.depth = self.depth + 1
    1                 if self.depth == 0 and not self.fragment_parsing then
****0                     self.state = state.after_elements
                      else
    1                     self.state = state.elements
                      end
                  end
              end
    1         return ev
****0     elseif self.state == state.after_elements then
****0         if self.buffer:starts_with('<!--') then
****0             return self:parse_comment()
****0         elseif self.buffer:starts_with('<%?xml') then
****0             return nil, 'Invalid declaration @ ' .. self.current_idx
****0         elseif self.buffer:starts_with('<?') then
****0             return self:parse_pi()
              else
****0             return nil, string.format('Unknown token: %s', self.buffer:current_char())
              end
          else
****0         return nil
          end
      end



    1 return Puller

==============================================================================
/usr/local/share/lua/5.3/busted/block.lua
==============================================================================
****0 local getfenv = require 'busted.compatibility'.getfenv
****0 local unpack = require 'busted.compatibility'.unpack
****0 local shuffle = require 'busted.utils'.shuffle

      local function sort(elements)
****0   table.sort(elements, function(t1, t2)
****0     if t1.name and t2.name then
****0       return t1.name < t2.name
          end
****0     return t2.name ~= nil
        end)
****0   return elements
      end

      return function(busted)
    1   local block = {}
    1   local root = busted.context.get()

    1   function block.reject(descriptor, element)
  221     element.env[descriptor] = function(...)
****0       error("'" .. descriptor .. "' not supported inside current context block", 2)
          end
        end

    1   function block.rejectAll(element)
   13     local env = getfenv(element.run)
   13     block.reject('randomize', element)
  234     for descriptor, _ in pairs(busted.executors) do
  221       if root.env[descriptor] and (env ~= _G and env[descriptor] or rawget(env, descriptor)) then
  208         block.reject(descriptor, element)
            end
          end
        end

        local function exec(descriptor, element)
****0     if not element.env then element.env = {} end
****0     block.rejectAll(element)
****0     local ret = { busted.safe(descriptor, element.run, element) }
****0     return unpack(ret)
        end

    1   function block.execAllOnce(descriptor, current, err)
   52     local parent = busted.context.parent(current)

   52     if parent then
   39       local success = block.execAllOnce(descriptor, parent)
   39       if not success then
****0         return success
            end
          end

   52     if not current[descriptor] then
   11       current[descriptor] = {}
          end
   52     local list = current[descriptor]
   52     if list.success ~= nil then
   41       return list.success
          end

   11     local success = true
   11     for _, v in ipairs(list) do
****0       if not exec(descriptor, v):success() then
****0         if err then err(descriptor) end
****0         success = false
            end
          end

   11     list.success = success

   11     return success
        end

    1   function block.execAll(descriptor, current, propagate, err)
   66     local parent = busted.context.parent(current)

   66     if propagate and parent then
   39       local success, ancestor = block.execAll(descriptor, parent, propagate)
   39       if not success then
****0         return success, ancestor
            end
          end

   66     local list = current[descriptor] or {}

   66     local success = true
   66     for _, v in ipairs(list) do
****0       if not exec(descriptor, v):success() then
****0         if err then err(descriptor) end
****0         success = nil
            end
          end
   66     return success, current
        end

    1   function block.dexecAll(descriptor, current, propagate, err)
   77     local parent = busted.context.parent(current)
   77     local list = current[descriptor] or {}

   77     local success = true
   77     for _, v in ipairs(list) do
****0       if not exec(descriptor, v):success() then
****0         if err then err(descriptor) end
****0         success = nil
            end
          end

   77     if propagate and parent then
   39       if not block.dexecAll(descriptor, parent, propagate) then
****0         success = nil
            end
          end
   77     return success
        end

    1   function block.lazySetup(element, err)
   13     return block.execAllOnce('lazy_setup', element, err)
        end

    1   function block.lazyTeardown(element, err)
   14     if element.lazy_setup and element.lazy_setup.success ~= nil then
   11       block.dexecAll('lazy_teardown', element, nil, err)
   11       element.lazy_setup.success = nil
          end
        end

    1   function block.setup(element, err)
   14       return block.execAll('strict_setup', element, nil, err)
        end

    1   function block.teardown(element, err)
   14       return block.dexecAll('strict_teardown', element, nil, err)
        end

    1   function block.execute(descriptor, element)
   13     if not element.env then element.env = {} end

   13     local randomize = busted.randomize
   13     local randomseed = busted.randomseed
   13     element.env.randomize = function(...)
****0       randomize = (select('#', ...) == 0 or ...)
****0       if randomize then
****0         randomseed = tonumber(({...})[1]) or tonumber(({...})[2]) or randomseed
            end
          end

   13     if busted.safe(descriptor, element.run, element):success() then
   13       if busted.sort then
****0         sort(busted.context.children(element))
   13       elseif randomize then
****0         element.randomseed = randomseed
****0         shuffle(busted.context.children(element), randomseed)
            end

   13       if block.setup(element) then
   13         busted.execute(element)
            end

   13       block.lazyTeardown(element)
   13       block.teardown(element)
          end
        end

    1   return block
      end

==============================================================================
/usr/local/share/lua/5.3/busted/compatibility.lua
==============================================================================
****0 return {
****0   getfenv = getfenv or function(f)
   13     f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)
          local name, value
   13     local up = 0

          repeat
   26       up = up + 1
   26       name, value = debug.getupvalue(f, up)
   26     until name == '_ENV' or name == nil

   13     return name and value or _G
        end,

****0   setfenv = setfenv or function(f, t)
    2     f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)
          local name
    2     local up = 0

          repeat
    2       up = up + 1
    2       name = debug.getupvalue(f, up)
    2     until name == '_ENV' or name == nil

    2     if name then
    2       debug.upvaluejoin(f, up, function() return name end, 1)
    2       debug.setupvalue(f, up, t)
          end

    2     if f ~= 0 then return f end
        end,

        loadstring = loadstring or load,
        unpack = table.unpack or unpack,

        exit = function(code, force)
****0     if not force and code ~= 0 and _VERSION:match('^Lua 5%.[12]$') then
****0       error()
****0     elseif code ~= 0 then
****0       code = 1
          end
****0     if _VERSION == 'Lua 5.1' and
****0       (type(jit) ~= 'table' or not jit.version or jit.version_num < 20000) then
            -- From Lua 5.1 manual:
            -- > The userdata itself is freed only in the next
            -- > garbage-collection cycle.
            -- Call collectgarbage() while collectgarbage('count')
            -- changes + 3 times, at least 3 times,
            -- at max 100 times (to prevent infinite loop).
****0       local times_const = 0
****0       for i = 1, 100 do
****0         local count_before = collectgarbage("count")
****0         collectgarbage()
****0         local count_after = collectgarbage("count")
****0         if count_after == count_before then
****0           times_const = times_const + 1
****0           if times_const > 3 then
                  break
                end
              else
****0           times_const = 0
              end
            end
          end
****0     os.exit(code, true)
        end,

        execute = require 'pl.utils'.execute,
      }

==============================================================================
/usr/local/share/lua/5.3/busted/context.lua
==============================================================================
****0 local tablex = require 'pl.tablex'

      local function save()
    2   local g = {}
   76   for k,_ in next, _G, nil do
   74     g[k] = rawget(_G, k)
        end
    2   return {
    2     gmt = debug.getmetatable(_G),
    2     g = g,
    2     loaded = tablex.copy(package.loaded)
    2   }
      end

      local function restore(state)
    2   setmetatable(_G, state.gmt)
   76   for k,_ in next, _G, nil do
   74     rawset(_G, k, state.g[k])
        end
  191   for k,_ in pairs(package.loaded) do
  189     package.loaded[k] = state.loaded[k]
        end
      end

      return function()
****0   local context = {}

****0   local data = { descriptor = 'suite', attributes = {} }
****0   local parents = {}
****0   local children = {}
****0   local stack = {}
****0   local states = {}

****0   function context.ref()
****0     local ref = {}
****0     local ctx = data

          local function unwrap(element, levels)
****0       local levels = levels or 1
****0       local parent = element
****0       for i = 1, levels do
****0         parent = ref.parent(parent)
****0         if not parent then break end
            end
****0       if not element.env then element.env = {} end
****0       setmetatable(element.env, {
              __newindex = function(self, key, value)
****0           if not parent then
****0             _G[key] = value
                else
****0             if not parent.env then parent.env = {} end
****0             parent.env[key] = value
                end
              end
            })
          end

          local function push_state(current)
   26       local state = false
   26       if current.attributes.envmode == 'insulate' then
    2         state = save()
   24       elseif current.attributes.envmode == 'unwrap' then
****0         unwrap(current)
   24       elseif current.attributes.envmode == 'expose' then
****0         unwrap(current, 2)
            end
   26       table.insert(states, state)
          end

          local function pop_state(current)
   26       local state = table.remove(states)
   26       if current.attributes.envmode == 'expose' then
****0         states[#states] = states[#states] and save()
            end
   26       if state then
    2         restore(state)
            end
          end

****0     function ref.get(key)
 1266       if not key then return ctx end
****0       return ctx[key]
          end

****0     function ref.set(key, value)
****0       ctx[key] = value
          end

****0     function ref.clear()
****0       data = { descriptor = 'suite', attributes = {} }
****0       parents = {}
****0       children = {}
****0       stack = {}
****0       states = {}
****0       ctx = data
          end

****0     function ref.attach(child)
   26       if not children[ctx] then children[ctx] = {} end
   26       parents[child] = ctx
   26       table.insert(children[ctx], child)
          end

****0     function ref.children(parent)
   15       return children[parent] or {}
          end

****0     function ref.parent(child)
 5219       return parents[child]
          end

****0     function ref.push(current)
  106       if not parents[current] and current ~= data then error('Detached child. Cannot push.') end
  106       if ctx ~= current then push_state(current) end
  106       table.insert(stack, ctx)
  106       ctx = current
          end

****0     function ref.pop()
  106       local current = ctx
  106       ctx = table.remove(stack)
  106       if ctx ~= current then pop_state(current) end
  106       if not ctx then error('Context stack empty. Cannot pop.') end
          end

****0     return ref
        end

****0   return context
      end

==============================================================================
/usr/local/share/lua/5.3/busted/core.lua
==============================================================================
****0 local getfenv = require 'busted.compatibility'.getfenv
****0 local setfenv = require 'busted.compatibility'.setfenv
****0 local unpack = require 'busted.compatibility'.unpack
****0 local path = require 'pl.path'
****0 local pretty = require 'pl.pretty'
****0 local system = require 'system'
****0 local throw = error

****0 local failureMt = {
        __index = {},
        __tostring = function(e) return tostring(e.message) end,
****0   __type = 'failure'
      }

****0 local failureMtNoString = {
        __index = {},
****0   __type = 'failure'
      }

****0 local pendingMt = {
        __index = {},
        __tostring = function(p) return p.message end,
****0   __type = 'pending'
      }

      local function errortype(obj)
****0   local mt = debug.getmetatable(obj)
****0   if mt == failureMt or mt == failureMtNoString then
****0     return 'failure'
****0   elseif mt == pendingMt then
****0     return 'pending'
        end
****0   return 'error'
      end

      local function hasToString(obj)
****0   return type(obj) == 'string' or (debug.getmetatable(obj) or {}).__tostring
      end

      local function isCallable(obj)
    2   return type(obj) == 'function' or (debug.getmetatable(obj) or {}).__call
      end

      return function()
****0   local mediator = require 'mediator'()

****0   local busted = {}
****0   busted.version = '2.0.0-0'

****0   local root = require 'busted.context'()
****0   busted.context = root.ref()

****0   local environment = require 'busted.environment'(busted.context)

****0   busted.api = {}
****0   busted.executors = {}
****0   local executors = {}
****0   local eattributes = {}

****0   busted.gettime = system.gettime
****0   busted.monotime = system.monotime
****0   busted.sleep = system.sleep
****0   busted.status = require 'busted.status'

****0   function busted.getTrace(element, level, msg)
          local function trimTrace(info)
****0       local index = info.traceback:find('\n%s*%[C]')
****0       info.traceback = info.traceback:sub(1, index)
****0       return info
          end
   24     level = level or  3

   24     local thisdir = path.dirname(debug.getinfo(1, 'Sl').source)
   24     local info = debug.getinfo(level, 'Sl')
   24     while info.what == 'C' or info.short_src:match('luassert[/\\].*%.lua$') or
   24           (info.source:sub(1,1) == '@' and thisdir == path.dirname(info.source)) do
****0       level = level + 1
****0       info = debug.getinfo(level, 'Sl')
          end

   24     info.traceback = debug.traceback('', level)
   24     info.message = msg

   24     local file = busted.getFile(element)
   24     return file and file.getTrace(file.name, info) or trimTrace(info)
        end

****0   function busted.rewriteMessage(element, message, trace)
****0     local file = busted.getFile(element)
****0     local msg = hasToString(message) and tostring(message)
****0     msg = msg or (message ~= nil and pretty.write(message) or 'Nil error')
****0     msg = (file and file.rewriteMessage and file.rewriteMessage(file.name, msg) or msg)

****0     local hasFileLine = msg:match('^[^\n]-:%d+: .*')
****0     if not hasFileLine then
****0       local trace = trace or busted.getTrace(element, 3, message)
****0       local fileline = trace.short_src .. ':' .. trace.currentline .. ': '
****0       msg = fileline .. msg
          end

****0     return msg
        end

****0   function busted.publish(...)
   81     return mediator:publish(...)
        end

****0   function busted.subscribe(...)
   31     return mediator:subscribe(...)
        end

****0   function busted.unsubscribe(...)
****0     return mediator:removeSubscriber(...)
        end

****0   function busted.getFile(element)
   24     local parent = busted.context.parent(element)

   37     while parent do
   37       if parent.file then
    2         local file = parent.file[1]
    2         return {
    2           name = file.name,
    2           getTrace = file.run.getTrace,
    2           rewriteMessage = file.run.rewriteMessage
    2         }
            end

   35       if parent.descriptor == 'file' then
   22         return {
   22           name = parent.name,
   22           getTrace = parent.run.getTrace,
   22           rewriteMessage = parent.run.rewriteMessage
   22         }
            end

   13       parent = busted.context.parent(parent)
          end

****0     return parent
        end

****0   function busted.fail(msg, level)
****0     local rawlevel = (type(level) ~= 'number' or level <= 0) and level
****0     local level = level or 1
****0     local _, emsg = pcall(throw, msg, rawlevel or level+2)
****0     local e = { message = emsg }
****0     setmetatable(e, hasToString(msg) and failureMt or failureMtNoString)
****0     throw(e, rawlevel or level+1)
        end

****0   function busted.pending(msg)
****0     local p = { message = msg }
****0     setmetatable(p, pendingMt)
****0     throw(p)
        end

****0   function busted.bindfenv(callable, var, value)
****0     local env = {}
****0     local f = (debug.getmetatable(callable) or {}).__call or callable
****0     setmetatable(env, { __index = getfenv(f) })
****0     env[var] = value
****0     setfenv(f, env)
        end

****0   function busted.wrap(callable)
    2     if isCallable(callable) then
            -- prioritize __call if it exists, like in files
    2       environment.wrap((debug.getmetatable(callable) or {}).__call or callable)
          end
        end

****0   function busted.safe(descriptor, run, element)
  106     busted.context.push(element)
          local trace, message
  106     local status = 'success'

  212     local ret = { xpcall(run, function(msg)
****0       status = errortype(msg)
****0       trace = busted.getTrace(element, 3, msg)
****0       message = busted.rewriteMessage(element, msg, trace)
  212     end) }

  106     if not ret[1] then
****0       if status == 'success' then
****0         status = 'error'
****0         trace = busted.getTrace(element, 3, ret[2])
****0         message = busted.rewriteMessage(element, ret[2], trace)
****0       elseif status == 'failure' and descriptor ~= 'it' then
              -- Only 'it' blocks can generate test failures. Failures in all
              -- other blocks are errors outside the test.
****0         status = 'error'
            end
            -- Note: descriptor may be different from element.descriptor when
            -- safe_publish is used (i.e. for test start/end). The safe_publish
            -- descriptor needs to be different for 'it' blocks so that we can
            -- detect that a 'failure' in a test start/end handler is not really
            -- a test failure, but rather an error outside the test, much like a
            -- failure in a support function (i.e. before_each/after_each or
            -- setup/teardown).
****0       busted.publish({ status, element.descriptor }, element, busted.context.parent(element), message, trace)
          end
  106     ret[1] = busted.status(status)

  106     busted.context.pop()
  106     return unpack(ret)
        end

****0   function busted.safe_publish(descriptor, channel, element, ...)
   54     local args = {...}
   54     local n = select('#', ...)
   54     if channel[2] == 'start' then
   27       element.starttick = busted.monotime()
   27       element.starttime = busted.gettime()
   27     elseif channel[2] == 'end' then
   27       element.endtime = busted.gettime()
   27       element.endtick = busted.monotime()
   27       element.duration = element.starttick and (element.endtick - element.starttick)
          end
  108     local status = busted.safe(descriptor, function()
   54       busted.publish(channel, element, unpack(args, 1, n))
  108     end, element)
   54     return status:success()
        end

****0   function busted.exportApi(key, value)
****0     busted.api[key] = value
        end

****0   function busted.export(key, value)
****0     busted.exportApi(key, value)
****0     environment.set(key, value)
        end

****0   function busted.hide(key, value)
****0     busted.api[key] = nil
****0     environment.set(key, nil)
        end

****0   function busted.register(descriptor, executor, attributes)
          local alias = nil
****0     if type(executor) == 'string' then
****0       alias = descriptor
****0       descriptor = executor
****0       executor = executors[descriptor]
****0       attributes = attributes or eattributes[descriptor]
****0       executors[alias] = executor
****0       eattributes[alias] = attributes
          else
****0       if executor ~= nil and not isCallable(executor) then
****0         attributes = executor
****0         executor = nil
            end
****0       executors[descriptor] = executor
****0       eattributes[descriptor] = attributes
          end

          local publisher = function(name, fn)
   26       if not fn and type(name) == 'function' then
****0         fn = name
****0         name = alias
            end

            local trace

   26       local ctx = busted.context.get()
   26       if busted.context.parent(ctx) then
   24         trace = busted.getTrace(ctx, 3, name)
            end

            local publish = function(f)
   26         busted.publish({ 'register', descriptor }, name, f, trace, attributes)
            end

   26       if fn then publish(fn) else return publish end
          end

****0     local edescriptor = alias or descriptor
****0     busted.executors[edescriptor] = publisher
****0     busted.export(edescriptor, publisher)

****0     busted.subscribe({ 'register', descriptor }, function(name, fn, trace, attributes)
   26       local ctx = busted.context.get()
   26       local plugin = {
   26         descriptor = descriptor,
   26         attributes = attributes or {},
   26         name = name,
   26         run = fn,
   26         trace = trace,
   26         starttick = nil,
   26         endtick = nil,
   26         starttime = nil,
   26         endtime = nil,
   26         duration = nil,
            }

   26       busted.context.attach(plugin)

   26       if not ctx[descriptor] then
   11         ctx[descriptor] = { plugin }
            else
   15         ctx[descriptor][#ctx[descriptor]+1] = plugin
            end
          end)
        end

****0   function busted.execute(current)
   14     if not current then current = busted.context.get() end
   40     for _, v in pairs(busted.context.children(current)) do
   26       local executor = executors[v.descriptor]
   26       if executor and not busted.skipAll then
   52         busted.safe(v.descriptor, function() executor(v) end, v)
            end
          end
        end

****0   return busted
      end

==============================================================================
/usr/local/share/lua/5.3/busted/environment.lua
==============================================================================
****0 local setfenv = require 'busted.compatibility'.setfenv

      return function(context)

****0   local environment = {}

        local function getEnv(self, key)
 6069     if not self then return nil end
****0     return
 5857       self.env and self.env[key] or
 4872       getEnv(context.parent(self), key) or
 5857       _G[key]
        end

        local function setEnv(self, key, value)
    1     if not self.env then self.env = {} end
    1     self.env[key] = value
        end

        local function __index(self, key)
 1197     return getEnv(context.get(), key)
        end

        local function __newindex(self, key, value)
    1     setEnv(context.get(), key, value)
        end

****0   local env = setmetatable({}, { __index=__index, __newindex=__newindex })

****0   function environment.wrap(fn)
    2     return setfenv(fn, env)
        end

****0   function environment.set(key, value)
****0     local env = context.get('env')

****0     if not env then
****0       env = {}
****0       context.set('env', env)
          end

****0     env[key] = value
        end
****0   return environment
      end

==============================================================================
/usr/local/share/lua/5.3/busted/execute.lua
==============================================================================
    1 local shuffle = require 'busted.utils'.shuffle
    1 local urandom = require 'busted.utils'.urandom
    1 local tablex = require 'pl.tablex'

      local function sort(elements)
****0   table.sort(elements, function(t1, t2)
****0     if t1.name and t2.name then
****0       return t1.name < t2.name
          end
****0     return t2.name ~= nil
        end)
****0   return elements
      end

      return function(busted)
    1   local block = require 'busted.block'(busted)

        local function execute(runs, options)
    1     local root = busted.context.get()
    1     local children = tablex.copy(busted.context.children(root))

          local function suite_reset()
****0       local oldctx = busted.context.get()

****0       busted.context.clear()
****0       local ctx = busted.context.get()
****0       for k, v in pairs(oldctx) do
****0         ctx[k] = v
            end

****0       for _, child in ipairs(children) do
****0         for descriptor, _ in pairs(busted.executors) do
****0           child[descriptor] = nil
              end
****0         busted.context.attach(child)
            end

****0       busted.randomseed = tonumber(options.seed) or urandom() or os.time()
          end

    2     for i = 1, runs do
    1       if i > 1 then
****0         suite_reset()
****0         root = busted.context.get()
****0         busted.safe_publish('suite', { 'suite', 'reset' }, root, i, runs)
            end

    1       if options.sort then
****0         sort(busted.context.children(root))
    1       elseif options.shuffle then
****0         root.randomseed = busted.randomseed
****0         shuffle(busted.context.children(root), busted.randomseed)
            end

    1       local seed = (busted.randomize and busted.randomseed or nil)
    1       if busted.safe_publish('suite', { 'suite', 'start' }, root, i, runs, seed) then
    1         if block.setup(root) then
    1           busted.execute()
              end
    1         block.lazyTeardown(root)
    1         block.teardown(root)
            end
    1       busted.safe_publish('suite', { 'suite', 'end' }, root, i, runs)

    1       if busted.skipAll then
              break
            end
          end
        end

    1   return execute
      end

==============================================================================
/usr/local/share/lua/5.3/busted/init.lua
==============================================================================
      local function init(busted)
****0   local block = require 'busted.block'(busted)

        local file = function(file)
    2     busted.wrap(file.run)
    2     if busted.safe_publish('file', { 'file', 'start' }, file) then
    2       block.execute('file', file)
          end
    2     busted.safe_publish('file', { 'file', 'end' }, file)
        end

        local describe = function(describe)
   11     local parent = busted.context.parent(describe)
   11     if busted.safe_publish('describe', { 'describe', 'start' }, describe, parent) then
   11       block.execute('describe', describe)
          end
   11     busted.safe_publish('describe', { 'describe', 'end' }, describe, parent)
        end

        local it = function(element)
   13     local parent = busted.context.parent(element)
          local finally

   13     if not block.lazySetup(parent) then
            -- skip test if any setup failed
****0       return
          end

   13     if not element.env then element.env = {} end

   13     block.rejectAll(element)
   13     element.env.finally = function(fn) finally = fn end
   13     element.env.pending = busted.pending

   13     local pass, ancestor = block.execAll('before_each', parent, true)

   13     if pass then
   13       local status = busted.status('success')
   13       if busted.safe_publish('test', { 'test', 'start' }, element, parent) then
   13         status:update(busted.safe('it', element.run, element))
   13         if finally then
****0           block.reject('pending', element)
****0           status:update(busted.safe('finally', finally, element))
              end
            else
****0         status = busted.status('error')
            end
   13       busted.safe_publish('test', { 'test', 'end' }, element, parent, tostring(status))
          end

   13     block.dexecAll('after_each', ancestor, true)
        end

        local pending = function(element)
****0     local parent = busted.context.parent(element)
****0     local status = 'pending'
****0     if not busted.safe_publish('it', { 'test', 'start' }, element, parent) then
****0       status = 'error'
          end
****0     busted.safe_publish('it', { 'test', 'end' }, element, parent, status)
        end

****0   busted.register('file', file, { envmode = 'insulate' })

****0   busted.register('describe', describe)
****0   busted.register('insulate', 'describe', { envmode = 'insulate' })
****0   busted.register('expose', 'describe', { envmode = 'expose' })

****0   busted.register('it', it)

****0   busted.register('pending', pending)

****0   busted.register('before_each', { envmode = 'unwrap' })
****0   busted.register('after_each', { envmode = 'unwrap' })

****0   busted.register('lazy_setup', { envmode = 'unwrap' })
****0   busted.register('lazy_teardown', { envmode = 'unwrap' })
****0   busted.register('strict_setup', { envmode = 'unwrap' })
****0   busted.register('strict_teardown', { envmode = 'unwrap' })

****0   busted.register('setup', 'strict_setup')
****0   busted.register('teardown', 'strict_teardown')

****0   busted.register('context', 'describe')
****0   busted.register('spec', 'it')
****0   busted.register('test', 'it')

****0   busted.hide('file')

****0   local assert = require 'luassert'
****0   local spy    = require 'luassert.spy'
****0   local mock   = require 'luassert.mock'
****0   local stub   = require 'luassert.stub'
****0   local match  = require 'luassert.match'

****0   busted.export('assert', assert)
****0   busted.export('spy', spy)
****0   busted.export('mock', mock)
****0   busted.export('stub', stub)
****0   busted.export('match', match)

****0   busted.exportApi('publish', busted.publish)
****0   busted.exportApi('subscribe', busted.subscribe)
****0   busted.exportApi('unsubscribe', busted.unsubscribe)

****0   busted.exportApi('bindfenv', busted.bindfenv)
****0   busted.exportApi('fail', busted.fail)
****0   busted.exportApi('gettime', busted.gettime)
****0   busted.exportApi('monotime', busted.monotime)
****0   busted.exportApi('sleep', busted.sleep)
****0   busted.exportApi('parent', busted.context.parent)
****0   busted.exportApi('children', busted.context.children)
****0   busted.exportApi('version', busted.version)

****0   busted.bindfenv(assert, 'error', busted.fail)
****0   busted.bindfenv(assert.is_true, 'error', busted.fail)

****0   return busted
      end

****0 return setmetatable({}, {
        __call = function(self, busted)
****0     init(busted)

****0     return setmetatable(self, {
            __index = function(self, key)
   56         return busted.api[key]
            end,

            __newindex = function(self, key, value)
****0         error('Attempt to modify busted')
            end
          })
        end
      })

==============================================================================
/usr/local/share/lua/5.3/busted/languages/en.lua
==============================================================================
    1 local s = require('say')

    1 s:set_namespace('en')

      -- 'Pending: test.lua @ 12 \n description
    1 s:set('output.pending', 'Pending')
    1 s:set('output.failure', 'Failure')
    1 s:set('output.error', 'Error')
    1 s:set('output.success', 'Success')

    1 s:set('output.pending_plural', 'pending')
    1 s:set('output.failure_plural', 'failures')
    1 s:set('output.error_plural', 'errors')
    1 s:set('output.success_plural', 'successes')

    1 s:set('output.pending_zero', 'pending')
    1 s:set('output.failure_zero', 'failures')
    1 s:set('output.error_zero', 'errors')
    1 s:set('output.success_zero', 'successes')

    1 s:set('output.pending_single', 'pending')
    1 s:set('output.failure_single', 'failure')
    1 s:set('output.error_single', 'error')
    1 s:set('output.success_single', 'success')

    1 s:set('output.seconds', 'seconds')

    1 s:set('output.no_test_files_match', 'No test files found matching Lua pattern: %s')
    1 s:set('output.file_not_found', 'Cannot find file or directory: %s')

      -- definitions following are not used within the 'say' namespace
    1 return {
    1   failure_messages = {
    1     'You have %d busted specs',
    1     'Your specs are busted',
    1     'Your code is bad and you should feel bad',
    1     'Your code is in the Danger Zone',
    1     'Strange game. The only way to win is not to test',
    1     'My grandmother wrote better specs on a 3 86',
    1     'Every time there\'s a failure, drink another beer',
          'Feels bad man'
    1   },
    1   success_messages = {
    1     'Aww yeah, passing specs',
    1     'Doesn\'t matter, had specs',
    1     'Feels good, man',
    1     'Great success',
          'Tests pass, drink another beer',
    1   }
    1 }

==============================================================================
/usr/local/share/lua/5.3/busted/modules/files/lua.lua
==============================================================================
    1 local path = require 'pl.path'

    1 local ret = {}

      local getTrace = function(filename, info)
   24   local index = info.traceback:find('\n%s*%[C]')
   24   info.traceback = info.traceback:sub(1, index)
   24   return info
      end

      ret.match = function(busted, filename)
    2   return path.extension(filename) == '.lua'
      end

      ret.load = function(busted, filename)
    2   local file, err = loadfile(filename)
    2   if not file then
****0     busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})
        end
    2   return file, getTrace
      end

    1 return ret

==============================================================================
/usr/local/share/lua/5.3/busted/modules/files/moonscript.lua
==============================================================================
    1 local path = require 'pl.path'

    2 local ok, moonscript, line_tables, util = pcall(function()
    1   return require 'moonscript', require 'moonscript.line_tables', require 'moonscript.util'
      end)

    1 local _cache = {}

      -- find the line number of `pos` chars into fname
      local lookup_line = function(fname, pos)
****0   if not _cache[fname] then
****0     local f = io.open(fname)
****0     _cache[fname] = f:read('*a')
****0     f:close()
        end

****0   return util.pos_to_line(_cache[fname], pos)
      end

      local rewrite_linenumber = function(fname, lineno)
****0   local tbl = line_tables['@' .. fname]
****0   if fname and tbl then
****0     for i = lineno, 0 ,-1 do
****0       if tbl[i] then
****0         return lookup_line(fname, tbl[i])
            end
          end
        end

****0   return lineno
      end

      local rewrite_filename = function(filename)
        -- sometimes moonscript gives files like [string "./filename.moon"], so
        -- we'll chop it up to only get the filename.
****0   return filename:match('string "(.+)"') or filename
      end

      local rewrite_traceback = function(fname, trace)
        local rewrite_one = function(line, pattern, sub)
****0     if line == nil then return '' end

****0     local fname, lineno = line:match(pattern)

****0     if fname and lineno then
****0       fname = rewrite_filename(fname)
****0       local new_lineno = rewrite_linenumber(fname, tonumber(lineno))
****0       if new_lineno then
****0         line = line:gsub(sub:format(tonumber(lineno)), sub:format(tonumber(new_lineno)))
            end
          end

****0     return line
        end

****0   local lines = {}
****0   local j = 0

****0   for line in trace:gmatch('[^\r\n]+') do
****0     j = j + 1
****0     line = rewrite_one(line, '%s*(.-):(%d+): ', ':%d:')
****0     line = rewrite_one(line, '<(.*):(%d+)>', ':%d>')
****0     lines[j] = line
        end

****0   return '\n' .. table.concat(lines, trace:match('[\r\n]+')) .. '\n'
      end

    1 local ret = {}

      local getTrace = function(filename, info)
****0   local index = info.traceback:find('\n%s*%[C]')
****0   info.traceback = info.traceback:sub(1, index)

****0   info.short_src = rewrite_filename(info.short_src)
****0   info.traceback = rewrite_traceback(filename, info.traceback)
****0   info.linedefined = rewrite_linenumber(filename, info.linedefined)
****0   info.currentline = rewrite_linenumber(filename, info.currentline)

****0   return info
      end

      local rewriteMessage = function(filename, message)
****0   local fname, line, msg = message:match('^([^\n]-):(%d+): (.*)')
****0   if not fname then
****0     return message
        end

****0   fname = rewrite_filename(fname)
****0   line = rewrite_linenumber(fname, tonumber(line))

****0   return fname .. ':' .. tostring(line) .. ': ' .. msg
      end

      ret.match = function(busted, filename)
****0   return ok and path.extension(filename) == '.moon'
      end

      ret.load = function(busted, filename)
****0   local file, err = moonscript.loadfile(filename)
****0   if not file then
****0     busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})
        end
****0   return file, getTrace, rewriteMessage
      end

    1 return ret

==============================================================================
/usr/local/share/lua/5.3/busted/modules/filter_loader.lua
==============================================================================
      return function()
        local function filter(busted, options)
          local getFullName = function(name)
   13       local parent = busted.context.get()
   13       local names = { name }

   39       while parent and (parent.name or parent.descriptor) and
   39             parent.descriptor ~= 'file' do
   26         table.insert(names, 1, parent.name or parent.descriptor)
   26         parent = busted.context.parent(parent)
            end

   13       return table.concat(names, ' ')
          end

          local hasTag = function(name, tag)
****0       local found = name:find('#' .. tag)
****0       return (found ~= nil)
          end

          local filterExcludeTags = function(name)
   24       for i, tag in pairs(options.excludeTags) do
****0         if hasTag(name, tag) then
****0           return nil, false
              end
            end
   24       return nil, true
          end

          local filterTags = function(name)
   13       local fullname = getFullName(name)
   13       for i, tag in pairs(options.tags) do
****0         if hasTag(fullname, tag) then
****0           return nil, true
              end
            end
   13       return nil, (#options.tags == 0)
          end

          local filterOutNames = function(name)
   24       for _, filter in pairs(options.filterOut) do
****0         if getFullName(name):find(filter) ~= nil then
****0           return nil, false
              end
            end
   24       return nil, true
          end

          local filterNames = function(name)
   13       for _, filter in pairs(options.filter) do
****0         if getFullName(name):find(filter) ~= nil then
****0           return nil, true
              end
            end
   13       return nil, (#options.filter == 0)
          end

          local printTestName = function(element, parent, status)
****0       if not (options.suppressPending and status == 'pending') then
****0         local fullname = getFullName()
****0         local trace = element.trace
****0         if trace and trace.what == 'Lua' then
****0           fullname = trace.short_src .. ':' .. trace.currentline .. ': ' .. fullname
              end
****0         print(fullname)
            end
****0       return nil, false
          end

          local ignoreAll = function()
****0       return nil, false
          end

    1     local noop = function() end
          local stubOut = function(descriptor, name, fn, ...)
****0       if fn == noop then
****0         return nil, true
            end
****0       busted.publish({ 'register', descriptor }, name, noop, ...)
****0       return nil, false
          end

          local skipOnError = function()
****0       return nil, not busted.skipAll
          end

          local applyFilter = function(descriptors, name, fn)
    8       if options[name] and options[name] ~= '' then
   14         for _, descriptor in ipairs(descriptors) do
   10           busted.subscribe({ 'register', descriptor }, fn, { priority = 1 })
              end
            end
          end

          local applyDescFilter = function(descriptors, name, fn)
****0       if options[name] and options[name] ~= '' then
****0         for _, descriptor in ipairs(descriptors) do
****0           local f = function(...) return fn(descriptor, ...) end
****0           busted.subscribe({ 'register', descriptor }, f, { priority = 1 })
              end
            end
          end

    1     if options.list then
****0       busted.subscribe({ 'suite', 'start' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'suite', 'end' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'file', 'start' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'file', 'end' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'describe', 'start' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'describe', 'end' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'test', 'start' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'test', 'end' }, printTestName, { priority = 1 })
****0       applyDescFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'list', stubOut)
****0       applyDescFilter({ 'lazy_setup', 'lazy_teardown' }, 'list', stubOut)
****0       applyDescFilter({ 'strict_setup', 'strict_teardown' }, 'list', stubOut)
****0       applyDescFilter({ 'it', 'pending' }, 'list', stubOut)
          end

    1     applyFilter({ 'lazy_setup', 'lazy_teardown' }, 'nokeepgoing', skipOnError)
    1     applyFilter({ 'strict_setup', 'strict_teardown' }, 'nokeepgoing', skipOnError)
    1     applyFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'nokeepgoing', skipOnError)
    1     applyFilter({ 'file', 'describe', 'it', 'pending' }, 'nokeepgoing', skipOnError)

          -- The following filters are applied in reverse order
    1     applyFilter({ 'it', 'pending' }            , 'filter'     , filterNames      )
    1     applyFilter({ 'describe', 'it', 'pending' }, 'filterOut'  , filterOutNames   )
    1     applyFilter({ 'it', 'pending' }            , 'tags'       , filterTags       )
    1     applyFilter({ 'describe', 'it', 'pending' }, 'excludeTags', filterExcludeTags)
        end

****0   return filter
      end

==============================================================================
/usr/local/share/lua/5.3/busted/modules/output_handler_loader.lua
==============================================================================
****0 local path = require 'pl.path'
****0 local hasMoon, moonscript = pcall(require, 'moonscript')
****0 local utils = require 'busted.utils'

      return function()
        local loadOutputHandler = function(busted, output, options)
          local handler

    1     utils.copy_interpreter_args(options.arguments)
    2     local success, err = pcall(function()
    1       if output:match('%.lua$') then
****0         handler = dofile(path.normpath(output))
    1       elseif hasMoon and output:match('%.moon$') then
****0         handler = moonscript.dofile(path.normpath(output))
            else
    1         handler = require('busted.outputHandlers.' .. output)
            end
          end)

    1     if not success and err:match("module '.-' not found:") then
****0       success, err = pcall(function() handler = require(output) end)
          end

    1     if not success then
****0       busted.publish({ 'error', 'output' }, { descriptor = 'output', name = output }, nil, err, {})
****0       handler = require('busted.outputHandlers.' .. options.defaultOutput)
          end

    1     if options.enableSound then
****0       require 'busted.outputHandlers.sound'(options)
          end

    1     handler(options):subscribe(options)
        end

****0   return loadOutputHandler
      end

==============================================================================
/usr/local/share/lua/5.3/busted/modules/test_file_loader.lua
==============================================================================
    1 local s = require 'say'

      return function(busted, loaders)
    1   local path = require 'pl.path'
    1   local dir = require 'pl.dir'
    1   local tablex = require 'pl.tablex'
    1   local fileLoaders = {}

    3   for _, v in pairs(loaders) do
    2     local loader = require('busted.modules.files.'..v)
    2     fileLoaders[#fileLoaders+1] = loader
        end

        local getTestFiles = function(rootFile, patterns, options)
          local fileList

    1     if path.isfile(rootFile) then
****0       fileList = { rootFile }
    1     elseif path.isdir(rootFile) then
    1       local getfiles = options.recursive and dir.getallfiles or dir.getfiles
    1       fileList = getfiles(rootFile)

    2       fileList = tablex.filter(fileList, function(filename)
    3         local basename = path.basename(filename)
    3         for _, patt in ipairs(options.excludes) do
****0           if patt ~= '' and basename:find(patt) then
****0             return nil
                end
              end
    4         for _, patt in ipairs(patterns) do
    3           if basename:find(patt) then
    2             return true
                end
              end
    1         return #patterns == 0
            end)

    2       fileList = tablex.filter(fileList, function(filename)
    2         if path.is_windows then
****0           return not filename:find('%\\%.%w+.%w+', #rootFile)
              else
    2           return not filename:find('/%.%w+.%w+', #rootFile)
              end
            end)
          else
****0       busted.publish({ 'error' }, {}, nil, s('output.file_not_found'):format(rootFile), {})
****0       fileList = {}
          end

    1     table.sort(fileList)
    1     return fileList
        end

        local getAllTestFiles = function(rootFiles, patterns, options)
    1     local fileList = {}
    2     for _, root in ipairs(rootFiles) do
    1       tablex.insertvalues(fileList, getTestFiles(root, patterns, options))
          end
    1     return fileList
        end

        -- runs a testfile, loading its tests
        local loadTestFile = function(busted, filename)
    2     for _, v in pairs(fileLoaders) do
    2       if v.match(busted, filename) then
    2         return v.load(busted, filename)
            end
          end
        end

        local loadTestFiles = function(rootFiles, patterns, options)
    1     local fileList = getAllTestFiles(rootFiles, patterns, options)

    3     for i, fileName in ipairs(fileList) do
    2       local testFile, getTrace, rewriteMessage = loadTestFile(busted, fileName)

    2       if testFile then
    4         local file = setmetatable({
    2           getTrace = getTrace,
    2           rewriteMessage = rewriteMessage
    2         }, {
    2           __call = testFile
              })

    2         busted.executors.file(fileName, file)
            end
          end

    1     if #fileList == 0 then
****0       local pattern = patterns[1]
****0       if #patterns > 1 then
****0         pattern = '\n\t' .. table.concat(patterns, '\n\t')
            end
****0       busted.publish({ 'error' }, {}, nil, s('output.no_test_files_match'):format(pattern), {})
          end

    1     return fileList
        end

    1   return loadTestFiles, loadTestFile, getAllTestFiles
      end


==============================================================================
/usr/local/share/lua/5.3/busted/outputHandlers/base.lua
==============================================================================
      return function()
    1   local busted = require 'busted'
    1   local handler = {
    1     successes = {},
    1     successesCount = 0,
    1     pendings = {},
    1     pendingsCount = 0,
    1     failures = {},
    1     failuresCount = 0,
    1     errors = {},
    1     errorsCount = 0,
    1     inProgress = {}
        }

        handler.cancelOnPending = function(element, parent, status)
   39     return not ((element.descriptor == 'pending' or status == 'pending') and handler.options.suppressPending)
        end

        handler.subscribe = function(handler, options)
    1     require('busted.languages.en')
    1     handler.options = options

    1     if options.language ~= 'en' then
****0       require('busted.languages.' .. options.language)
          end

    1     busted.subscribe({ 'suite', 'reset' }, handler.baseSuiteReset, { priority = 1 })
    1     busted.subscribe({ 'suite', 'start' }, handler.baseSuiteStart, { priority = 1 })
    1     busted.subscribe({ 'suite', 'end' }, handler.baseSuiteEnd, { priority = 1 })
    1     busted.subscribe({ 'test', 'start' }, handler.baseTestStart, { priority = 1, predicate = handler.cancelOnPending })
    1     busted.subscribe({ 'test', 'end' }, handler.baseTestEnd, { priority = 1, predicate = handler.cancelOnPending })
    1     busted.subscribe({ 'pending' }, handler.basePending, { priority = 1, predicate = handler.cancelOnPending })
    1     busted.subscribe({ 'failure', 'it' }, handler.baseTestFailure, { priority = 1 })
    1     busted.subscribe({ 'error', 'it' }, handler.baseTestError, { priority = 1 })
    1     busted.subscribe({ 'failure' }, handler.baseError, { priority = 1 })
    1     busted.subscribe({ 'error' }, handler.baseError, { priority = 1 })
        end

        handler.getFullName = function(context)
   13     local parent = busted.parent(context)
   13     local names = { (context.name or context.descriptor) }

   39     while parent and (parent.name or parent.descriptor) and
   39           parent.descriptor ~= 'file' do

   26       table.insert(names, 1, parent.name or parent.descriptor)
   26       parent = busted.parent(parent)
          end

   13     return table.concat(names, ' ')
        end

        handler.format = function(element, parent, message, debug, isError)
          local function copyElement(e)
   13       local copy = {}
  156       for k,v in next, e do
  143         if type(v) ~= 'function' and k ~= 'env' then
  117           copy[k] = v
              end
            end
   13       return copy
          end

   13     local formatted = {
   13       trace = debug or element.trace,
   13       element = copyElement(element),
   13       name = handler.getFullName(element),
   13       message = message,
   13       randomseed = parent and parent.randomseed,
   13       isError = isError
          }
   13     formatted.element.trace = element.trace or debug

   13     return formatted
        end

        handler.getDuration = function()
    1     if not handler.endTick or not handler.startTick then
****0       return 0
          end

    1     return handler.endTick - handler.startTick
        end

        handler.baseSuiteStart = function(suite)
    1     handler.startTick = suite.starttick
    1     handler.startTime = suite.starttime
    1     return nil, true
        end

        handler.baseSuiteReset = function()
****0     handler.successes = {}
****0     handler.successesCount = 0
****0     handler.pendings = {}
****0     handler.pendingsCount = 0
****0     handler.failures = {}
****0     handler.failuresCount = 0
****0     handler.errors = {}
****0     handler.errorsCount = 0
****0     handler.inProgress = {}

****0     return nil, true
        end

        handler.baseSuiteEnd = function(suite)
    1     handler.endTick = suite.endtick
    1     handler.endTime = suite.endtime
    1     return nil, true
        end

        handler.baseTestStart = function(element, parent)
   13     handler.inProgress[tostring(element)] = {}
   13     return nil, true
        end

        handler.baseTestEnd = function(element, parent, status, debug)
          local insertTable

   13     if status == 'success' then
   13       insertTable = handler.successes
   13       handler.successesCount = handler.successesCount + 1
****0     elseif status == 'pending' then
****0       insertTable = handler.pendings
****0       handler.pendingsCount = handler.pendingsCount + 1
****0     elseif status == 'failure' then
            -- failure already saved in failure handler
****0       handler.failuresCount = handler.failuresCount + 1
****0       return nil, true
****0     elseif status == 'error' then
            -- error count already incremented and saved in error handler
****0       insertTable = handler.errors
****0       return nil, true
          end

   13     local formatted = handler.format(element, parent, element.message, debug)

   13     local id = tostring(element)
   13     if handler.inProgress[id] then
   13       for k, v in pairs(handler.inProgress[id]) do
****0         formatted[k] = v
            end

   13       handler.inProgress[id] = nil
          end

   13     table.insert(insertTable, formatted)

   13     return nil, true
        end

        handler.basePending = function(element, parent, message, debug)
****0     local id = tostring(element)
****0     handler.inProgress[id].message = message
****0     handler.inProgress[id].trace = debug
****0     return nil, true
        end

        handler.baseTestFailure = function(element, parent, message, debug)
****0     table.insert(handler.failures, handler.format(element, parent, message, debug))
****0     return nil, true
        end

        handler.baseTestError = function(element, parent, message, debug)
****0     handler.errorsCount = handler.errorsCount + 1
****0     table.insert(handler.errors, handler.format(element, parent, message, debug, true))
****0     return nil, true
        end

        handler.baseError = function(element, parent, message, debug)
****0     if element.descriptor ~= 'it' then
****0       handler.errorsCount = handler.errorsCount + 1
****0       table.insert(handler.errors, handler.format(element, parent, message, debug, true))
          end

****0     return nil, true
        end

    1   return handler
      end

==============================================================================
/usr/local/share/lua/5.3/busted/outputHandlers/utfTerminal.lua
==============================================================================
    1 local s = require 'say'
    1 local pretty = require 'pl.pretty'
    1 local io = io

      local colors

    1 if package.config:sub(1,1) == '\\' and not os.getenv("ANSICON") then
        -- Disable colors on Windows.
****0   colors = setmetatable({}, {__index = function() return function(s) return s end end})
      else
    1   colors = require 'term.colors'
      end

      return function(options)
    1   local busted = require 'busted'
    1   local handler = require 'busted.outputHandlers.base'()

    1   local successDot = colors.green('â—')
    1   local failureDot = colors.red('â—¼')
    1   local errorDot   = colors.magenta('âœ±')
    1   local pendingDot = colors.yellow('â—Œ')

        local pendingDescription = function(pending)
****0     local name = pending.name

****0     local string = colors.yellow(s('output.pending')) .. ' â†’ ' ..
****0       colors.cyan(pending.trace.short_src) .. ' @ ' ..
****0       colors.cyan(pending.trace.currentline)  ..
****0       '\n' .. colors.bright(name)

****0     if type(pending.message) == 'string' then
****0       string = string .. '\n' .. pending.message
****0     elseif pending.message ~= nil then
****0       string = string .. '\n' .. pretty.write(pending.message)
          end

****0     return string
        end

        local failureMessage = function(failure)
****0     local string = failure.randomseed and ('Random seed: ' .. failure.randomseed .. '\n') or ''
****0     if type(failure.message) == 'string' then
****0       string = string .. failure.message
****0     elseif failure.message == nil then
****0       string = string .. 'Nil error'
          else
****0       string = string .. pretty.write(failure.message)
          end

****0     return string
        end

        local failureDescription = function(failure, isError)
****0     local string = colors.red(s('output.failure')) .. ' â†’ '
****0     if isError then
****0       string = colors.magenta(s('output.error')) .. ' â†’ '
          end

****0     if not failure.element.trace or not failure.element.trace.short_src then
****0       string = string ..
****0         colors.cyan(failureMessage(failure)) .. '\n' ..
****0         colors.bright(failure.name)
          else
****0       string = string ..
****0         colors.cyan(failure.element.trace.short_src) .. ' @ ' ..
****0         colors.cyan(failure.element.trace.currentline) .. '\n' ..
****0         colors.bright(failure.name) .. '\n' ..
****0         failureMessage(failure)
          end

****0     if options.verbose and failure.trace and failure.trace.traceback then
****0       string = string .. '\n' .. failure.trace.traceback
          end

****0     return string
        end

        local statusString = function()
    1     local successString = s('output.success_plural')
    1     local failureString = s('output.failure_plural')
    1     local pendingString = s('output.pending_plural')
    1     local errorString = s('output.error_plural')

    1     local sec = handler.getDuration()
    1     local successes = handler.successesCount
    1     local pendings = handler.pendingsCount
    1     local failures = handler.failuresCount
    1     local errors = handler.errorsCount

    1     if successes == 0 then
****0       successString = s('output.success_zero')
    1     elseif successes == 1 then
****0       successString = s('output.success_single')
          end

    1     if failures == 0 then
    1       failureString = s('output.failure_zero')
****0     elseif failures == 1 then
****0       failureString = s('output.failure_single')
          end

    1     if pendings == 0 then
    1       pendingString = s('output.pending_zero')
****0     elseif pendings == 1 then
****0       pendingString = s('output.pending_single')
          end

    1     if errors == 0 then
    1       errorString = s('output.error_zero')
****0     elseif errors == 1 then
****0       errorString = s('output.error_single')
          end

    1     local formattedTime = ('%.6f'):format(sec):gsub('([0-9])0+$', '%1')

    1     return colors.green(successes) .. ' ' .. successString .. ' / ' ..
    1       colors.red(failures) .. ' ' .. failureString .. ' / ' ..
    1       colors.magenta(errors) .. ' ' .. errorString .. ' / ' ..
    1       colors.yellow(pendings) .. ' ' .. pendingString .. ' : ' ..
    1       colors.bright(formattedTime) .. ' ' .. s('output.seconds')
        end

        handler.testEnd = function(element, parent, status, debug)
   13     if not options.deferPrint then
   13       local string = successDot

   13       if status == 'pending' then
****0         string = pendingDot
   13       elseif status == 'failure' then
****0         string = failureDot
   13       elseif status == 'error' then
****0         string = errorDot
            end

   13       io.write(string)
   13       io.flush()
          end

   13     return nil, true
        end

        handler.suiteStart = function(suite, count, total)
    1     local runString = (total > 1 and '\nRepeating all tests (run %u of %u) . . .\n\n' or '')
    1     io.write(runString:format(count, total))
    1     io.flush()

    1     return nil, true
        end

        handler.suiteEnd = function(suite, count, total)
    1     print('')
    1     print(statusString())

    1     for i, pending in pairs(handler.pendings) do
****0       print('')
****0       print(pendingDescription(pending))
          end

    1     for i, err in pairs(handler.failures) do
****0       print('')
****0       print(failureDescription(err))
          end

    1     for i, err in pairs(handler.errors) do
****0       print('')
****0       print(failureDescription(err, true))
          end

    1     return nil, true
        end

        handler.error = function(element, parent, message, debug)
****0     io.write(errorDot)
****0     io.flush()

****0     return nil, true
        end

    1   busted.subscribe({ 'test', 'end' }, handler.testEnd, { predicate = handler.cancelOnPending })
    1   busted.subscribe({ 'suite', 'start' }, handler.suiteStart)
    1   busted.subscribe({ 'suite', 'end' }, handler.suiteEnd)
    1   busted.subscribe({ 'error', 'file' }, handler.error)
    1   busted.subscribe({ 'failure', 'file' }, handler.error)
    1   busted.subscribe({ 'error', 'describe' }, handler.error)
    1   busted.subscribe({ 'failure', 'describe' }, handler.error)

    1   return handler
      end

==============================================================================
/usr/local/share/lua/5.3/busted/runner.lua
==============================================================================
      -- Busted command-line runner

****0 local path = require 'pl.path'
****0 local tablex = require 'pl.tablex'
****0 local term = require 'term'
****0 local utils = require 'busted.utils'
****0 local exit = require 'busted.compatibility'.exit
****0 local loadstring = require 'busted.compatibility'.loadstring
****0 local loaded = false

      return function(options)
****0   if loaded then return function() end else loaded = true end

****0   local isatty = io.type(io.stdout) == 'file' and term.isatty(io.stdout)
****0   options = tablex.update(require 'busted.options', options or {})
****0   options.output = options.output or (isatty and 'utfTerminal' or 'plainTerminal')

****0   local busted = require 'busted.core'()

****0   local cli = require 'busted.modules.cli'(options)
****0   local filterLoader = require 'busted.modules.filter_loader'()
****0   local helperLoader = require 'busted.modules.helper_loader'()
****0   local outputHandlerLoader = require 'busted.modules.output_handler_loader'()

****0   local luacov = require 'busted.modules.luacov'()

****0   require 'busted'(busted)

****0   local level = 2
****0   local info = debug.getinfo(level, 'Sf')
****0   local source = info.source
****0   local fileName = source:sub(1,1) == '@' and source:sub(2) or nil
****0   local forceExit = fileName == nil

        -- Parse the cli arguments
****0   local appName = path.basename(fileName or 'busted')
****0   cli:set_name(appName)
****0   local cliArgs, err = cli:parse(arg)
****0   if not cliArgs then
****0     io.stderr:write(err .. '\n')
****0     exit(1, forceExit)
        end

****0   if cliArgs.version then
          -- Return early if asked for the version
****0     print(busted.version)
****0     exit(0, forceExit)
        end

        -- Load current working directory
****0   local _, err = path.chdir(path.normpath(cliArgs.directory))
****0   if err then
****0     io.stderr:write(appName .. ': error: ' .. err .. '\n')
****0     exit(1, forceExit)
        end

        -- If coverage arg is passed in, load LuaCovsupport
****0   if cliArgs.coverage then
****0     local ok, err = luacov()
    1     if not ok then
****0       io.stderr:write(appName .. ': error: ' .. err .. '\n')
****0       exit(1, forceExit)
          end
        end

        -- If auto-insulate is disabled, re-register file without insulation
    1   if not cliArgs['auto-insulate'] then
****0     busted.register('file', 'file', {})
        end

        -- If lazy is enabled, make lazy setup/teardown the default
    1   if cliArgs.lazy then
****0     busted.register('setup', 'lazy_setup')
****0     busted.register('teardown', 'lazy_teardown')
        end

        -- Add additional package paths based on lpath and cpath cliArgs
    1   if #cliArgs.lpath > 0 then
    1     package.path = (cliArgs.lpath .. ';' .. package.path):gsub(';;',';')
        end

    1   if #cliArgs.cpath > 0 then
    1     package.cpath = (cliArgs.cpath .. ';' .. package.cpath):gsub(';;',';')
        end

        -- Load and execute commands given on the command-line
    1   if cliArgs.e then
    1     for k,v in ipairs(cliArgs.e) do
****0       loadstring(v)()
          end
        end

        -- watch for test errors and failures
    1   local failures = 0
    1   local errors = 0
    1   local quitOnError = not cliArgs['keep-going']

    2   busted.subscribe({ 'error', 'output' }, function(element, parent, message)
****0     io.stderr:write(appName .. ': error: Cannot load output library: ' .. element.name .. '\n' .. message .. '\n')
****0     return nil, true
        end)

    2   busted.subscribe({ 'error', 'helper' }, function(element, parent, message)
****0     io.stderr:write(appName .. ': error: Cannot load helper script: ' .. element.name .. '\n' .. message .. '\n')
****0     return nil, true
        end)

    2   busted.subscribe({ 'error' }, function(element, parent, message)
****0     errors = errors + 1
****0     busted.skipAll = quitOnError
****0     return nil, true
        end)

    2   busted.subscribe({ 'failure' }, function(element, parent, message)
****0     if element.descriptor == 'it' then
****0       failures = failures + 1
          else
****0       errors = errors + 1
          end
****0     busted.skipAll = quitOnError
****0     return nil, true
        end)

        -- Set up randomization options
    1   busted.sort = cliArgs['sort-tests']
    1   busted.randomize = cliArgs['shuffle-tests']
    1   busted.randomseed = tonumber(cliArgs.seed) or utils.urandom() or os.time()

        -- Set up output handler to listen to events
    2   outputHandlerLoader(busted, cliArgs.output, {
    1     defaultOutput = options.output,
    1     enableSound = cliArgs['enable-sound'],
    1     verbose = cliArgs.verbose,
    1     suppressPending = cliArgs['suppress-pending'],
    1     language = cliArgs.lang,
    1     deferPrint = cliArgs['defer-print'],
    1     arguments = cliArgs.Xoutput,
        })

        -- Pre-load the LuaJIT 'ffi' module if applicable
    1   local isJit = (tostring(assert):match('builtin') ~= nil)
    1   if isJit then
          -- pre-load the ffi module, such that it becomes part of the environment
          -- and Busted will not try to GC and reload it. The ffi is not suited
          -- for that and will occasionally segfault if done so.
****0     local ffi = require "ffi"

          -- Now patch ffi.cdef to only be called once with each definition, as it
          -- will error on re-registering.
****0     local old_cdef = ffi.cdef
****0     local exists = {}
          ffi.cdef = function(def)
****0       if exists[def] then return end
****0       exists[def] = true
****0       return old_cdef(def)
          end
        end

        -- Set up helper script
    1   if cliArgs.helper and cliArgs.helper ~= '' then
****0     helperLoader(busted, cliArgs.helper, {
            verbose = cliArgs.verbose,
            language = cliArgs.lang,
****0       arguments = cliArgs.Xhelper
          })
        end

        -- Load tag and test filters
    2   filterLoader(busted, {
    1     tags = cliArgs.tags,
    1     excludeTags = cliArgs['exclude-tags'],
    1     filter = cliArgs.filter,
    1     filterOut = cliArgs['filter-out'],
    1     list = cliArgs.list,
    1     nokeepgoing = not cliArgs['keep-going'],
    1     suppressPending = cliArgs['suppress-pending'],
        })

    1   if cliArgs.ROOT then
          -- Load test directories/files
    1     local rootFiles = cliArgs.ROOT
    1     local patterns = cliArgs.pattern
    1     local testFileLoader = require 'busted.modules.test_file_loader'(busted, cliArgs.loaders)
    2     testFileLoader(rootFiles, patterns, {
    1       excludes = cliArgs['exclude-pattern'],
    1       verbose = cliArgs.verbose,
    1       recursive = cliArgs['recursive'],
    1     })
        else
          -- Running standalone, use standalone loader
****0     local testFileLoader = require 'busted.modules.standalone_loader'(busted)
****0     testFileLoader(info, { verbose = cliArgs.verbose })
        end

    1   local runs = cliArgs['repeat']
    1   local execute = require 'busted.execute'(busted)
    2   execute(runs, {
    1     seed = cliArgs.seed,
    1     shuffle = cliArgs['shuffle-files'],
    1     sort = cliArgs['sort-files'],
        })

    1   busted.publish({ 'exit' })

    1   if options.standalone or failures > 0 or errors > 0 then
****0     exit(failures + errors, forceExit)
        end
      end

==============================================================================
/usr/local/share/lua/5.3/busted/status.lua
==============================================================================
      local function get_status(status)
  132   local smap = {
  132     ['success'] = 'success',
  132     ['pending'] = 'pending',
  132     ['failure'] = 'failure',
  132     ['error'] = 'error',
  132     ['true'] = 'success',
  132     ['false'] = 'failure',
  132     ['nil'] = 'error',
        }
  132   return smap[tostring(status)] or 'error'
      end

      return function(inital_status)
  119   local objstat = get_status(inital_status)
  119   local obj = {
  186     success = function(self) return (objstat == 'success') end,
  119     pending = function(self) return (objstat == 'pending') end,
  119     failure = function(self) return (objstat == 'failure') end,
  119     error   = function(self) return (objstat == 'error') end,

          get = function(self)
****0       return objstat
          end,

          set = function(self, status)
****0       objstat = get_status(status)
          end,

          update = function(self, status)
            -- prefer current failure/error status over new status
   13       status = get_status(status)
   13       if objstat == 'success' or (objstat == 'pending' and status ~= 'success') then
   13         objstat = status
            end
          end
        }

  238   return setmetatable(obj, {
  119     __index = {},
  145     __tostring = function(self) return objstat end
  119   })
      end

==============================================================================
/usr/local/share/lua/5.3/busted/utils.lua
==============================================================================
****0 return {
        copy_interpreter_args = function(arguments)
          -- copy non-positive command-line args auto-inserted by Lua interpreter
    1     if arguments and _G.arg then
    1       local i = 0
    5       while _G.arg[i] do
    4         arguments[i] = _G.arg[i]
    4         i = i - 1
            end
          end
        end,

        split = require 'pl.utils'.split,

        shuffle = function(t, seed)
****0     if seed then math.randomseed(seed) end
****0     local n = #t
****0     while n >= 2 do
****0       local k = math.random(n)
****0       t[n], t[k] = t[k], t[n]
****0       n = n - 1
          end
****0     return t
        end,

        urandom = function()
    1     local f = io.open('/dev/urandom', 'rb')
    1     if not f then return nil end
    1     local s = f:read(4) f:close()
    1     local bytes = {s:byte(1, 4)}
    1     local value = 0
    5     for _, v in ipairs(bytes) do
    4       value = value * 256 + v
          end
    1     return value
        end,
      }

==============================================================================
/usr/local/share/lua/5.3/luarocks/core/dir.lua
==============================================================================

****0 local dir = {}

      local require = nil
      --------------------------------------------------------------------------------

      --- Describe a path in a cross-platform way.
      -- Use this function to avoid platform-specific directory
      -- separators in other modules. Removes trailing slashes from
      -- each component given, to avoid repeated separators.
      -- Separators inside strings are kept, to handle URLs containing
      -- protocols.
      -- @param ... strings representing directories
      -- @return string: a string with a platform-specific representation
      -- of the path.
****0 function dir.path(...)
   30    local t = {...}
   30    while t[1] == "" do
****0       table.remove(t, 1)
         end
   30    return (table.concat(t, "/"):gsub("([^:])/+", "%1/"):gsub("^/+", "/"):gsub("/*$", ""))
      end

      --- Split protocol and path from an URL or local pathname.
      -- URLs should be in the "protocol://path" format.
      -- For local pathnames, "file" is returned as the protocol.
      -- @param url string: an URL or a local pathname.
      -- @return string, string: the protocol, and the pathname without the protocol.
****0 function dir.split_url(url)
   60    assert(type(url) == "string")
         
   60    local protocol, pathname = url:match("^([^:]*)://(.*)")
   60    if not protocol then
   60       protocol = "file"
   60       pathname = url
         end
   60    return protocol, pathname
      end

      --- Normalize a url or local path.
      -- URLs should be in the "protocol://path" format. System independent
      -- forward slashes are used, removing trailing and double slashes
      -- @param url string: an URL or a local pathname.
      -- @return string: Normalized result.
****0 function dir.normalize(name)
   60    local protocol, pathname = dir.split_url(name)
   60    pathname = pathname:gsub("\\", "/"):gsub("(.)/*$", "%1"):gsub("//", "/")
   60    if protocol ~= "file" then pathname = protocol .."://"..pathname end
   60    return pathname
      end

****0 return dir


==============================================================================
/usr/local/share/lua/5.3/luarocks/core/manif.lua
==============================================================================

      --- Core functions for querying manifest files.
****0 local manif = {}

****0 local persist = require("luarocks.core.persist")
****0 local cfg = require("luarocks.core.cfg")
****0 local dir = require("luarocks.core.dir")
****0 local util = require("luarocks.core.util")
****0 local vers = require("luarocks.core.vers")
****0 local path = require("luarocks.core.path")
      local require = nil
      --------------------------------------------------------------------------------

      -- Table with repository identifiers as keys and tables mapping
      -- Lua versions to cached loaded manifests as values.
****0 local manifest_cache = {}

      --- Cache a loaded manifest.
      -- @param repo_url string: The repository identifier.
      -- @param lua_version string: Lua version in "5.x" format, defaults to installed version.
      -- @param manifest table: the manifest to be cached.
****0 function manif.cache_manifest(repo_url, lua_version, manifest)
****0    lua_version = lua_version or cfg.lua_version
****0    manifest_cache[repo_url] = manifest_cache[repo_url] or {}
****0    manifest_cache[repo_url][lua_version] = manifest
      end

      --- Attempt to get cached loaded manifest.
      -- @param repo_url string: The repository identifier.
      -- @param lua_version string: Lua version in "5.x" format, defaults to installed version.
      -- @return table or nil: loaded manifest or nil if cache is empty.
****0 function manif.get_cached_manifest(repo_url, lua_version)
   30    lua_version = lua_version or cfg.lua_version
   30    return manifest_cache[repo_url] and manifest_cache[repo_url][lua_version]
      end

      --- Back-end function that actually loads the manifest
      -- and stores it in the manifest cache.
      -- @param file string: The local filename of the manifest file.
      -- @param repo_url string: The repository identifier.
      -- @param lua_version string: Lua version in "5.x" format, defaults to installed version.
      -- @return table or (nil, string, string): the manifest or nil,
      -- error message and error code ("open", "load", "run").
****0 function manif.manifest_loader(file, repo_url, lua_version)
****0    local manifest, err, errcode = persist.load_into_table(file)
****0    if not manifest then
****0       return nil, "Failed loading manifest for "..repo_url..": "..err, errcode
         end
****0    manif.cache_manifest(repo_url, lua_version, manifest)
****0    return manifest, err, errcode
      end

      --- Load a local manifest describing a repository.
      -- This is used by the luarocks.loader only.
      -- @param repo_url string: URL or pathname for the repository.
      -- @return table or (nil, string, string): A table representing the manifest,
      -- or nil followed by an error message and an error code, see manifest_loader.
****0 function manif.fast_load_local_manifest(repo_url)
   30    assert(type(repo_url) == "string")

   30    local cached_manifest = manif.get_cached_manifest(repo_url)
   30    if cached_manifest then
   30       return cached_manifest
         end

****0    local pathname = dir.path(repo_url, "manifest")
****0    return manif.manifest_loader(pathname, repo_url, nil, true)
      end

****0 function manif.load_rocks_tree_manifests(deps_mode)
   15    local trees = {}
   30    path.map_trees(deps_mode, function(tree)
   30       local manifest, err = manif.fast_load_local_manifest(path.rocks_dir(tree))
   30       if manifest then
   30          table.insert(trees, {tree=tree, manifest=manifest})
            end
         end)
   15    return trees
      end

****0 function manif.scan_dependencies(name, version, tree_manifests, dest)
****0    if dest[name] then
****0       return
         end
****0    dest[name] = version

****0    for _, tree in ipairs(tree_manifests) do
****0       local manifest = tree.manifest

            local pkgdeps
****0       if manifest.dependencies and manifest.dependencies[name] then
****0          pkgdeps = manifest.dependencies[name][version]
            end
****0       if not pkgdeps then
****0          return nil
            end
****0       for _, dep in ipairs(pkgdeps) do
****0          local pkg, constraints = dep.name, dep.constraints

****0          for _, t in ipairs(tree_manifests) do
****0             local entries = t.manifest.repository[pkg]
****0             if entries then
****0                for ver, _ in util.sortedpairs(entries, vers.compare_versions) do
****0                   if (not constraints) or vers.match_constraints(vers.parse_version(ver), constraints) then
****0                      manif.scan_dependencies(pkg, ver, tree_manifests, dest)
                        end
                     end
                  end
               end
            end
         end
      end

****0 return manif

==============================================================================
/usr/local/share/lua/5.3/luarocks/core/path.lua
==============================================================================

      --- Core LuaRocks-specific path handling functions.
****0 local path = {}

****0 local cfg = require("luarocks.core.cfg")
****0 local dir = require("luarocks.core.dir")
      local require = nil
      --------------------------------------------------------------------------------

****0 function path.rocks_dir(tree)
   30    if tree == nil then
****0       tree = cfg.root_dir
         end
   30    if type(tree) == "string" then
****0       return dir.path(tree, cfg.rocks_subdir)
         end
   30    assert(type(tree) == "table")
   30    return tree.rocks_dir or dir.path(tree.root, cfg.rocks_subdir)
      end

      --- Produce a versioned version of a filename.
      -- @param file string: filename (must start with prefix)
      -- @param prefix string: Path prefix for file
      -- @param name string: Rock name
      -- @param version string: Rock version
      -- @return string: a pathname with the same directory parts and a versioned basename.
****0 function path.versioned_name(file, prefix, name, version)
****0    assert(type(file) == "string")
****0    assert(type(name) == "string" and not name:match("/"))
****0    assert(type(version) == "string")

****0    local rest = file:sub(#prefix+1):gsub("^/*", "")
****0    local name_version = (name.."_"..version):gsub("%-", "_"):gsub("%.", "_")
****0    return dir.path(prefix, name_version.."-"..rest)
      end

      --- Convert a pathname to a module identifier.
      -- In Unix, for example, a path "foo/bar/baz.lua" is converted to
      -- "foo.bar.baz"; "bla/init.lua" returns "bla.init"; "foo.so" returns "foo".
      -- @param file string: Pathname of module
      -- @return string: The module identifier, or nil if given path is
      -- not a conformant module path (the function does not check if the
      -- path actually exists).
****0 function path.path_to_module(file)
    9    assert(type(file) == "string")

    9    local name = file:match("(.*)%."..cfg.lua_extension.."$")
    9    if name then
    9       name = name:gsub("/", ".")
         else
****0       name = file:match("(.*)%."..cfg.lib_extension.."$")
****0       if name then
****0          name = name:gsub("/", ".")
            --[[ TODO disable static libs until we fix the conflict in the manifest, which will take extending the manifest format.
            else
               name = file:match("(.*)%."..cfg.static_lib_extension.."$")
               if name then
                  name = name:gsub("/", ".")
               end
            ]]
            end
         end
    9    if not name then name = file end
    9    name = name:gsub("^%.+", ""):gsub("%.+$", "")
    9    return name
      end

****0 function path.deploy_lua_dir(tree)
****0    if type(tree) == "string" then
****0       return dir.path(tree, cfg.lua_modules_path)
         else
****0       assert(type(tree) == "table")
****0       return tree.lua_dir or dir.path(tree.root, cfg.lua_modules_path)
         end
      end

****0 function path.deploy_lib_dir(tree)
****0    if type(tree) == "string" then
****0       return dir.path(tree, cfg.lib_modules_path)
         else
****0       assert(type(tree) == "table")
****0       return tree.lib_dir or dir.path(tree.root, cfg.lib_modules_path)
         end
      end

****0 local is_src_extension = { [".lua"] = true, [".tl"] = true, [".tld"] = true, [".moon"] = true }

      --- Return the pathname of the file that would be loaded for a module, indexed.
      -- @param file_name string: module file name as in manifest (eg. "socket/core.so")
      -- @param name string: name of the package (eg. "luasocket")
      -- @param version string: version number (eg. "2.0.2-1")
      -- @param tree string: repository path (eg. "/usr/local")
      -- @param i number: the index, 1 if version is the current default, > 1 otherwise.
      -- This is done this way for use by select_module in luarocks.loader.
      -- @return string: filename of the module (eg. "/usr/local/lib/lua/5.1/socket/core.so")
****0 function path.which_i(file_name, name, version, tree, i)
         local deploy_dir
****0    local extension = file_name:match("%.[a-z]+$")
****0    if is_src_extension[extension] then
****0       deploy_dir = path.deploy_lua_dir(tree)
****0       file_name = dir.path(deploy_dir, file_name)
         else
****0       deploy_dir = path.deploy_lib_dir(tree)
****0       file_name = dir.path(deploy_dir, file_name)
         end
****0    if i > 1 then
****0       file_name = path.versioned_name(file_name, deploy_dir, name, version)
         end
****0    return file_name
      end

****0 function path.rocks_tree_to_string(tree)
   60    if type(tree) == "string" then
****0       return tree
         else
   60       assert(type(tree) == "table")
   60       return tree.root
         end
      end

      --- Apply a given function to the active rocks trees based on chosen dependency mode.
      -- @param deps_mode string: Dependency mode: "one" for the current default tree,
      -- "all" for all trees, "order" for all trees with priority >= the current default,
      -- "none" for no trees (this function becomes a nop).
      -- @param fn function: function to be applied, with the tree dir (string) as the first
      -- argument and the remaining varargs of map_trees as the following arguments.
      -- @return a table with all results of invocations of fn collected.
****0 function path.map_trees(deps_mode, fn, ...)
   15    local result = {}
   15    local current = cfg.root_dir or cfg.rocks_trees[1]
   15    if deps_mode == "one" then
****0       table.insert(result, (fn(current, ...)) or 0)
         else
   15       local use = false
   15       if deps_mode == "all" then
****0          use = true
            end
   45       for _, tree in ipairs(cfg.rocks_trees or {}) do
   30          if dir.normalize(path.rocks_tree_to_string(tree)) == dir.normalize(path.rocks_tree_to_string(current)) then
   15             use = true
               end
   30          if use then
   30             table.insert(result, (fn(tree, ...)) or 0)
               end
            end
         end
   15    return result
      end

****0 return path

==============================================================================
/usr/local/share/lua/5.3/luarocks/loader.lua
==============================================================================

      --- A module which installs a Lua package loader that is LuaRocks-aware.
      -- This loader uses dependency information from the LuaRocks tree to load
      -- correct versions of modules. It does this by constructing a "context"
      -- table in the environment, which records which versions of packages were
      -- used to load previous modules, so that the loader chooses versions
      -- that are declared to be compatible with the ones loaded earlier.
****0 local loaders = package.loaders or package.searchers
      local require, ipairs, table, type, next, tostring, error =
****0       require, ipairs, table, type, next, tostring, error
****0 local unpack = unpack or table.unpack

****0 local loader = {}

****0 local is_clean = not package.loaded["luarocks.core.cfg"]

      -- This loader module depends only on core modules.
****0 local cfg = require("luarocks.core.cfg")
****0 local cfg_ok, err = cfg.init()
****0 if cfg_ok then
****0    cfg.init_package_paths()
      end

****0 local path = require("luarocks.core.path")
****0 local manif = require("luarocks.core.manif")
****0 local vers = require("luarocks.core.vers")
      local require = nil
      --------------------------------------------------------------------------------

      -- Workaround for wrappers produced by older versions of LuaRocks
****0 local temporary_global = false
****0 if luarocks then
         -- The site_config.lua file generated by old versions uses module(),
         -- so it produces a global `luarocks` table. Since we have the table,
         -- add the `loader` field to make the old wrappers happy.
****0    luarocks.loader = loader
      else
         -- When a new version is installed on top of an old version,
         -- site_config.lua may be replaced, and then it no longer creates
         -- a global.
         -- Detect when being called via -lluarocks.loader; this is
         -- most likely a wrapper.
****0    local info = debug.getinfo(2, "nS")
****0    if info.what == "C" and not info.name then
****0       luarocks = { loader = loader }
****0       temporary_global = true
            -- For the other half of this hack,
            -- see the next use of `temporary_global` below.
         end
      end

****0 loader.context = {}

      --- Process the dependencies of a package to determine its dependency
      -- chain for loading modules.
      -- @param name string: The name of an installed rock.
      -- @param version string: The version of the rock, in string format
****0 function loader.add_context(name, version)
         -- assert(type(name) == "string")
         -- assert(type(version) == "string")

****0    if temporary_global then
            -- The first thing a wrapper does is to call add_context.
            -- From here on, it's safe to clean the global environment.
****0       luarocks = nil
****0       temporary_global = false
         end

****0    local tree_manifests = manif.load_rocks_tree_manifests()
****0    if not tree_manifests then
****0       return nil
         end

****0    return manif.scan_dependencies(name, version, tree_manifests, loader.context)
      end

      --- Internal sorting function.
      -- @param a table: A provider table.
      -- @param b table: Another provider table.
      -- @return boolean: True if the version of a is greater than that of b.
      local function sort_versions(a,b)
****0    return a.version > b.version
      end

      --- Request module to be loaded through other loaders,
      -- once the proper name of the module has been determined.
      -- For example, in case the module "socket.core" has been requested
      -- to the LuaRocks loader and it determined based on context that
      -- the version 2.0.2 needs to be loaded and it is not the current
      -- version, the module requested for the other loaders will be
      -- "socket.core_2_0_2".
      -- @param module The module name requested by the user, such as "socket.core"
      -- @param name The rock name, such as "luasocket"
      -- @param version The rock version, such as "2.0.2-1"
      -- @param module_name The actual module name, such as "socket.core" or "socket.core_2_0_2".
      -- @return table or (nil, string): The module table as returned by some other loader,
      -- or nil followed by an error message if no other loader managed to load the module.
      local function call_other_loaders(module, name, version, module_name)
****0    for _, a_loader in ipairs(loaders) do
****0       if a_loader ~= loader.luarocks_loader then
****0          local results = { a_loader(module_name) }
****0          if type(results[1]) == "function" then
****0             return unpack(results)
               end
            end
         end
****0    return "Failed loading module "..module.." in LuaRocks rock "..name.." "..version
      end

      local function add_providers(providers, entries, tree, module, filter_file_name)
    9    for i, entry in ipairs(entries) do
    9       local name, version = entry:match("^([^/]*)/(.*)$")
    9       local file_name = tree.manifest.repository[name][version][1].modules[module]
    9       if type(file_name) ~= "string" then
****0          error("Invalid data in manifest file for module "..tostring(module).." (invalid data for "..tostring(name).." "..tostring(version)..")")
            end
    9       file_name = filter_file_name(file_name, name, version, tree.tree, i)
    9       if loader.context[name] == version then
    9          return name, version, file_name
            end
****0       version = vers.parse_version(version)
****0       table.insert(providers, {name = name, version = version, module_name = file_name, tree = tree})
         end
      end

      --- Search for a module in the rocks trees
      -- @param module string: module name (eg. "socket.core")
      -- @param filter_file_name function(string, string, string, string, number):
      -- a function that takes the module file name (eg "socket/core.so"), the rock name
      -- (eg "luasocket"), the version (eg "2.0.2-1"), the path of the rocks tree
      -- (eg "/usr/local"), and the numeric index of the matching entry, so the
      -- filter function can know if the matching module was the first entry or not.
      -- @return string, string, string, (string or table):
      -- * name of the rock containing the module (eg. "luasocket")
      -- * version of the rock (eg. "2.0.2-1")
      -- * return value of filter_file_name
      -- * tree of the module (string or table in `tree_manifests` format)
      local function select_module(module, filter_file_name)
         --assert(type(module) == "string")
         --assert(type(filter_module_name) == "function")

   15    local tree_manifests = manif.load_rocks_tree_manifests()
   15    if not tree_manifests then
****0       return nil
         end

   15    local providers = {}
         local initmodule
   45    for _, tree in ipairs(tree_manifests) do
   30       local entries = tree.manifest.modules[module]
   30       if entries then
    9          add_providers(providers, entries, tree, module, filter_file_name)
            else
   21          initmodule = initmodule or module .. ".init"
   21          entries = tree.manifest.modules[initmodule]
   21          if entries then
****0             add_providers(providers, entries, tree, initmodule, filter_file_name)
               end
            end
         end

   15    if next(providers) then
****0       table.sort(providers, sort_versions)
****0       local first = providers[1]
****0       return first.name, first.version.string, first.module_name, first.tree
         end
      end

      --- Search for a module
      -- @param module string: module name (eg. "socket.core")
      -- @return string, string, string, (string or table):
      -- * name of the rock containing the module (eg. "luasocket")
      -- * version of the rock (eg. "2.0.2-1")
      -- * name of the module (eg. "socket.core", or "socket.core_2_0_2" if file is stored versioned).
      -- * tree of the module (string or table in `tree_manifests` format)
      local function pick_module(module)
****0    return
   30       select_module(module, function(file_name, name, version, tree, i)
    9          if i > 1 then
****0             file_name = path.versioned_name(file_name, "", name, version)
               end
    9          return path.path_to_module(file_name)
            end)
      end

      --- Return the pathname of the file that would be loaded for a module.
      -- @param module string: module name (eg. "socket.core")
      -- @return filename of the module (eg. "/usr/local/lib/lua/5.1/socket/core.so"),
      -- the rock name and the rock version.
****0 function loader.which(module)
****0    local rock_name, rock_version, file_name = select_module(module, path.which_i)
****0    return file_name, rock_name, rock_version
      end

      --- Package loader for LuaRocks support.
      -- A module is searched in installed rocks that match the
      -- current LuaRocks context. If module is not part of the
      -- context, or if a context has not yet been set, the module
      -- in the package with the highest version is used.
      -- @param module string: The module name, like in plain require().
      -- @return table: The module table (typically), like in plain
      -- require(). See <a href="http://www.lua.org/manual/5.1/manual.html#pdf-require">require()</a>
      -- in the Lua reference manual for details.
****0 function loader.luarocks_loader(module)
   15    local name, version, module_name = pick_module(module)
   15    if not name then
   15       return "No LuaRocks module found for "..module
         else
****0       loader.add_context(name, version)
****0       return call_other_loaders(module, name, version, module_name)
         end
      end

****0 table.insert(loaders, 1, loader.luarocks_loader)

****0 if is_clean then
****0    for modname, _ in pairs(package.loaded) do
****0       if modname:match("^luarocks%.") then
****0          package.loaded[modname] = nil
            end
         end
      end

****0 return loader

==============================================================================
/usr/local/share/lua/5.3/luassert/assert.lua
==============================================================================
****0 local s = require 'say'
****0 local astate = require 'luassert.state'
****0 local util = require 'luassert.util'
****0 local unpack = require 'luassert.compatibility'.unpack
      local obj   -- the returned module table
****0 local level_mt = {}

      -- list of namespaces
****0 local namespace = require 'luassert.namespaces'

      local function geterror(assertion_message, failure_message, args)
****0   if util.hastostring(failure_message) then
****0     failure_message = tostring(failure_message)
****0   elseif failure_message ~= nil then
****0     failure_message = astate.format_argument(failure_message)
        end
****0   local message = s(assertion_message, obj:format(args))
****0   if message and failure_message then
****0     message = failure_message .. "\n" .. message
        end
****0   return message or failure_message
      end

****0 local __state_meta = {

        __call = function(self, ...)
****0     local keys = util.extract_keys("assertion", self.tokens)

          local assertion

****0     for _, key in ipairs(keys) do
****0       assertion = namespace.assertion[key] or assertion
          end

****0     if assertion then
****0       for _, key in ipairs(keys) do
****0         if namespace.modifier[key] then
****0           namespace.modifier[key].callback(self)
              end
            end

****0       local arguments = {...}
****0       arguments.n = select('#', ...) -- add argument count for trailing nils
****0       local val, retargs = assertion.callback(self, arguments, util.errorlevel())

****0       if not val == self.mod then
****0         local message = assertion.positive_message
****0         if not self.mod then
****0           message = assertion.negative_message
              end
****0         local err = geterror(message, rawget(self,"failure_message"), arguments)
****0         error(err or "assertion failed!", util.errorlevel())
            end

****0       if retargs then
****0         return unpack(retargs)
            end
****0       return ...
          else
****0       local arguments = {...}
****0       arguments.n = select('#', ...)
****0       self.tokens = {}

****0       for _, key in ipairs(keys) do
****0         if namespace.modifier[key] then
****0           namespace.modifier[key].callback(self, arguments, util.errorlevel())
              end
            end
          end

****0     return self
        end,

        __index = function(self, key)
****0     for token in key:lower():gmatch('[^_]+') do
****0       table.insert(self.tokens, token)
          end

****0     return self
        end
      }

****0 obj = {
        state = function() return setmetatable({mod=true, tokens={}}, __state_meta) end,

        -- registers a function in namespace
        register = function(self, nspace, name, callback, positive_message, negative_message)
****0     local lowername = name:lower()
****0     if not namespace[nspace] then
****0       namespace[nspace] = {}
          end
****0     namespace[nspace][lowername] = {
            callback = callback,
            name = lowername,
            positive_message=positive_message,
****0       negative_message=negative_message
          }
        end,

        -- unregisters a function in a namespace
        unregister = function(self, nspace, name)
****0     local lowername = name:lower()
****0     if not namespace[nspace] then
****0       namespace[nspace] = {}
          end
****0     namespace[nspace][lowername] = nil
        end,

        -- registers a formatter
        -- a formatter takes a single argument, and converts it to a string, or returns nil if it cannot format the argument
        add_formatter = function(self, callback)
****0     astate.add_formatter(callback)
        end,

        -- unregisters a formatter
        remove_formatter = function(self, fmtr)
****0     astate.remove_formatter(fmtr)
        end,

        format = function(self, args)
          -- args.n specifies the number of arguments in case of 'trailing nil' arguments which get lost
****0     local nofmt = args.nofmt or {}  -- arguments in this list should not be formatted
****0     local fmtargs = args.fmtargs or {} -- additional arguments to be passed to formatter
****0     for i = 1, (args.n or #args) do -- cannot use pairs because table might have nils
****0       if not nofmt[i] then
****0         local val = args[i]
****0         local valfmt = astate.format_argument(val, nil, fmtargs[i])
****0         if valfmt == nil then valfmt = tostring(val) end -- no formatter found
****0         args[i] = valfmt
            end
          end
****0     return args
        end,

        set_parameter = function(self, name, value)
****0     astate.set_parameter(name, value)
        end,
        
        get_parameter = function(self, name)
****0     return astate.get_parameter(name)
        end,  
        
        add_spy = function(self, spy)
****0     astate.add_spy(spy)
        end,
        
        snapshot = function(self)
****0     return astate.snapshot()
        end,
        
        level = function(self, level)
****0     return setmetatable({
****0         level = level
****0       }, level_mt)
        end,
        
        -- returns the level if a level-value, otherwise nil
        get_level = function(self, level)
****0     if getmetatable(level) ~= level_mt then
****0       return nil -- not a valid error-level
          end
****0     return level.level
        end,
      }

****0 local __meta = {

        __call = function(self, bool, message, level, ...)
  704     if not bool then
****0       local err_level = (self:get_level(level) or 1) + 1
****0       error(message or "assertion failed!", err_level)
          end
  704     return bool , message , level , ...
        end,

        __index = function(self, key)
****0     return rawget(self, key) or self.state()[key]
        end,

      }

****0 return setmetatable(obj, __meta)

==============================================================================
/usr/local/share/lua/5.3/mediator.lua
==============================================================================
      local function getUniqueId(obj)
   31   return tonumber(tostring(obj):match(':%s*[0xX]*(%x+)'), 16)
      end

      local function Subscriber(fn, options)
   31   local sub = {
   31     options = options or {},
   31     fn = fn,
   31     channel = nil,
          update = function(self, options)
****0       if options then
****0         self.fn = options.fn or self.fn
****0         self.options = options.options or self.options
            end
          end
        }
   31   sub.id = getUniqueId(sub)
   31   return sub
      end

      -- Channel class and functions --

      local function Channel(namespace, parent)
   25   return {
   25     stopped = false,
   25     namespace = namespace,
   25     callbacks = {},
   25     channels = {},
   25     parent = parent,

          addSubscriber = function(self, fn, options)
   31       local callback = Subscriber(fn, options)
   31       local priority = (#self.callbacks + 1)

   31       options = options or {}

   31       if options.priority and
   20         options.priority >= 0 and
   20         options.priority < priority
            then
   15           priority = options.priority
            end

   31       table.insert(self.callbacks, priority, callback)

   31       return callback
          end,

          getSubscriber = function(self, id)
****0       for i=1, #self.callbacks do
****0         local callback = self.callbacks[i]
****0         if callback.id == id then return { index = i, value = callback } end
            end
            local sub
****0       for _, channel in pairs(self.channels) do
****0         sub = channel:getSubscriber(id)
****0         if sub then break end
            end
****0       return sub
          end,

          setPriority = function(self, id, priority)
****0       local callback = self:getSubscriber(id)

****0       if callback.value then
****0         table.remove(self.callbacks, callback.index)
****0         table.insert(self.callbacks, priority, callback.value)
            end
          end,

          addChannel = function(self, namespace)
   25       self.channels[namespace] = Channel(namespace, self)
   25       return self.channels[namespace]
          end,

          hasChannel = function(self, namespace)
****0       return namespace and self.channels[namespace] and true
          end,

          getChannel = function(self, namespace)
  218       return self.channels[namespace] or self:addChannel(namespace)
          end,

          removeSubscriber = function(self, id)
****0       local callback = self:getSubscriber(id)

****0       if callback and callback.value then
****0         for _, channel in pairs(self.channels) do
****0           channel:removeSubscriber(id)
              end

****0         return table.remove(self.callbacks, callback.index)
            end
          end,

          publish = function(self, result, ...)
  307       for i = 1, #self.callbacks do
  143         local callback = self.callbacks[i]

              -- if it doesn't have a predicate, or it does and it's true then run it
  143         if not callback.options.predicate or callback.options.predicate(...) then
                 -- just take the first result and insert it into the result table
  143           local value, continue = callback.fn(...)

  143           if value then table.insert(result, value) end
  143           if not continue then return result end
              end
            end

  164       if parent then
  109         return parent:publish(result, ...)
            else
   55         return result
            end
          end
   25   }
      end

      -- Mediator class and functions --

****0 local Mediator = setmetatable(
      {
        Channel = Channel,
****0   Subscriber = Subscriber
      },
      {
        __call = function (fn, options)
****0     return {
            channel = Channel('root'),

            getChannel = function(self, channelNamespace)
  112         local channel = self.channel

  330         for i=1, #channelNamespace do
  218           channel = channel:getChannel(channelNamespace[i])
              end

  112         return channel
            end,

            subscribe = function(self, channelNamespace, fn, options)
   31         return self:getChannel(channelNamespace):addSubscriber(fn, options)
            end,

            getSubscriber = function(self, id, channelNamespace)
****0         return self:getChannel(channelNamespace):getSubscriber(id)
            end,

            removeSubscriber = function(self, id, channelNamespace)
****0         return self:getChannel(channelNamespace):removeSubscriber(id)
            end,

            publish = function(self, channelNamespace, ...)
   81         return self:getChannel(channelNamespace):publish({}, ...)
            end
          }
        end
      })
****0 return Mediator

==============================================================================
/usr/local/share/lua/5.3/pl/List.lua
==============================================================================
      --- Python-style list class.
      --
      -- **Please Note**: methods that change the list will return the list.
      -- This is to allow for method chaining, but please note that `ls = ls:sort()`
      -- does not mean that a new copy of the list is made. In-place (mutable) methods
      -- are marked as returning 'the list' in this documentation.
      --
      -- See the Guide for further @{02-arrays.md.Python_style_Lists|discussion}
      --
      -- See <a href="http://www.python.org/doc/current/tut/tut.html">http://www.python.org/doc/current/tut/tut.html</a>, section 5.1
      --
      -- **Note**: The comments before some of the functions are from the Python docs
      -- and contain Python code.
      --
      -- Written for Lua version Nick Trout 4.0; Redone for Lua 5.1, Steve Donovan.
      --
      -- Dependencies: `pl.utils`, `pl.tablex`, `pl.class`
      -- @classmod pl.List
      -- @pragma nostrip

    1 local tinsert,tremove,concat,tsort = table.insert,table.remove,table.concat,table.sort
    1 local setmetatable, getmetatable,type,tostring,string = setmetatable,getmetatable,type,tostring,string
    1 local tablex = require 'pl.tablex'
    1 local filter,imap,imap2,reduce,transform,tremovevalues = tablex.filter,tablex.imap,tablex.imap2,tablex.reduce,tablex.transform,tablex.removevalues
    1 local tsub = tablex.sub
    1 local utils = require 'pl.utils'
    1 local class = require 'pl.class'

    1 local array_tostring,split,assert_arg,function_arg = utils.array_tostring,utils.split,utils.assert_arg,utils.function_arg
    1 local normalize_slice = tablex._normalize_slice

      -- metatable for our list and map objects has already been defined..
    1 local Multimap = utils.stdmt.MultiMap
    1 local List = utils.stdmt.List

      local iter

    1 class(nil,nil,List)

      -- we want the result to be _covariant_, i.e. t must have type of obj if possible
      local function makelist (t,obj)
****0     local klass = List
****0     if obj then
****0         klass = getmetatable(obj)
          end
****0     return setmetatable(t,klass)
      end

      local function simple_table(t)
****0     return type(t) == 'table' and not getmetatable(t) and #t > 0
      end

    1 function List._create (src)
****0     if simple_table(src) then return src end
      end

    1 function List:_init (src)
****0     if self == src then return end -- existing table used as self!
****0     if src then
****0         for v in iter(src) do
****0             tinsert(self,v)
              end
          end
      end

      --- Create a new list. Can optionally pass a table;
      -- passing another instance of List will cause a copy to be created;
      -- this will return a plain table with an appropriate metatable.
      -- we pass anything which isn't a simple table to iterate() to work out
      -- an appropriate iterator
      -- @see List.iterate
      -- @param[opt] t An optional list-like table
      -- @return a new List
      -- @usage ls = List();  ls = List {1,2,3,4}
      -- @function List.new

    1 List.new = List

      --- Make a copy of an existing list.
      -- The difference from a plain 'copy constructor' is that this returns
      -- the actual List subtype.
    1 function List:clone()
****0     local ls = makelist({},self)
****0     ls:extend(self)
****0     return ls
      end

      --- Add an item to the end of the list.
      -- @param i An item
      -- @return the list
    1 function List:append(i)
****0     tinsert(self,i)
****0     return self
      end

    1 List.push = tinsert

      --- Extend the list by appending all the items in the given list.
      -- equivalent to 'a[len(a):] = L'.
      -- @tparam List L Another List
      -- @return the list
    1 function List:extend(L)
****0     assert_arg(1,L,'table')
****0     for i = 1,#L do tinsert(self,L[i]) end
****0     return self
      end

      --- Insert an item at a given position. i is the index of the
      -- element before which to insert.
      -- @int i index of element before whichh to insert
      -- @param x A data item
      -- @return the list
    1 function List:insert(i, x)
****0     assert_arg(1,i,'number')
****0     tinsert(self,i,x)
****0     return self
      end

      --- Insert an item at the begining of the list.
      -- @param x a data item
      -- @return the list
    1 function List:put (x)
****0     return self:insert(1,x)
      end

      --- Remove an element given its index.
      -- (equivalent of Python's del s[i])
      -- @int i the index
      -- @return the list
    1 function List:remove (i)
****0     assert_arg(1,i,'number')
****0     tremove(self,i)
****0     return self
      end

      --- Remove the first item from the list whose value is given.
      -- (This is called 'remove' in Python; renamed to avoid confusion
      -- with table.remove)
      -- Return nil if there is no such item.
      -- @param x A data value
      -- @return the list
    1 function List:remove_value(x)
****0     for i=1,#self do
****0         if self[i]==x then tremove(self,i) return self end
          end
****0     return self
       end

      --- Remove the item at the given position in the list, and return it.
      -- If no index is specified, a:pop() returns the last item in the list.
      -- The item is also removed from the list.
      -- @int[opt] i An index
      -- @return the item
    1 function List:pop(i)
****0     if not i then i = #self end
****0     assert_arg(1,i,'number')
****0     return tremove(self,i)
      end

    1 List.get = List.pop

      --- Return the index in the list of the first item whose value is given.
      -- Return nil if there is no such item.
      -- @function List:index
      -- @param x A data value
      -- @int[opt=1] idx where to start search
      -- @return the index, or nil if not found.

    1 local tfind = tablex.find
    1 List.index = tfind

      --- Does this list contain the value?
      -- @param x A data value
      -- @return true or false
    1 function List:contains(x)
****0     return tfind(self,x) and true or false
      end

      --- Return the number of times value appears in the list.
      -- @param x A data value
      -- @return number of times x appears
    1 function List:count(x)
****0     local cnt=0
****0     for i=1,#self do
****0         if self[i]==x then cnt=cnt+1 end
          end
****0     return cnt
      end

      --- Sort the items of the list, in place.
      -- @func[opt='<'] cmp an optional comparison function
      -- @return the list
    1 function List:sort(cmp)
****0     if cmp then cmp = function_arg(1,cmp) end
****0     tsort(self,cmp)
****0     return self
      end

      --- Return a sorted copy of this list.
      -- @func[opt='<'] cmp an optional comparison function
      -- @return a new list
    1 function List:sorted(cmp)
****0     return List(self):sort(cmp)
      end

      --- Reverse the elements of the list, in place.
      -- @return the list
    1 function List:reverse()
****0     local t = self
****0     local n = #t
****0     for i = 1,n/2 do
****0         t[i],t[n] = t[n],t[i]
****0         n = n - 1
          end
****0     return self
      end

      --- Return the minimum and the maximum value of the list.
      -- @return minimum value
      -- @return maximum value
    1 function List:minmax()
****0     local vmin,vmax = 1e70,-1e70
****0     for i = 1,#self do
****0         local v = self[i]
****0         if v < vmin then vmin = v end
****0         if v > vmax then vmax = v end
          end
****0     return vmin,vmax
      end

      --- Emulate list slicing.  like  'list[first:last]' in Python.
      -- If first or last are negative then they are relative to the end of the list
      -- eg. slice(-2) gives last 2 entries in a list, and
      -- slice(-4,-2) gives from -4th to -2nd
      -- @param first An index
      -- @param last An index
      -- @return a new List
    1 function List:slice(first,last)
****0     return tsub(self,first,last)
      end

      --- Empty the list.
      -- @return the list
    1 function List:clear()
****0     for i=1,#self do tremove(self) end
****0     return self
      end

    1 local eps = 1.0e-10

      --- Emulate Python's range(x) function.
      -- Include it in List table for tidiness
      -- @int start A number
      -- @int[opt] finish A number greater than start; if absent,
      -- then start is 1 and finish is start
      -- @int[opt=1] incr an increment (may be less than 1)
      -- @return a List from start .. finish
      -- @usage List.range(0,3) == List{0,1,2,3}
      -- @usage List.range(4) = List{1,2,3,4}
      -- @usage List.range(5,1,-1) == List{5,4,3,2,1}
    1 function List.range(start,finish,incr)
****0     if not finish then
****0         finish = start
****0         start = 1
          end
****0     if incr then
****0     assert_arg(3,incr,'number')
****0     if math.ceil(incr) ~= incr then finish = finish + eps end
          else
****0         incr = 1
          end
****0     assert_arg(1,start,'number')
****0     assert_arg(2,finish,'number')
****0     local t = List()
****0     for i=start,finish,incr do tinsert(t,i) end
****0     return t
      end

      --- list:len() is the same as #list.
    1 function List:len()
****0     return #self
      end

      -- Extended operations --

      --- Remove a subrange of elements.
      -- equivalent to 'del s[i1:i2]' in Python.
      -- @int i1 start of range
      -- @int i2 end of range
      -- @return the list
    1 function List:chop(i1,i2)
****0     return tremovevalues(self,i1,i2)
      end

      --- Insert a sublist into a list
      -- equivalent to 's[idx:idx] = list' in Python
      -- @int idx index
      -- @tparam List list list to insert
      -- @return the list
      -- @usage  l = List{10,20}; l:splice(2,{21,22});  assert(l == List{10,21,22,20})
    1 function List:splice(idx,list)
****0     assert_arg(1,idx,'number')
****0     idx = idx - 1
****0     local i = 1
****0     for v in iter(list) do
****0         tinsert(self,i+idx,v)
****0         i = i + 1
          end
****0     return self
      end

      --- General slice assignment s[i1:i2] = seq.
      -- @int i1  start index
      -- @int i2  end index
      -- @tparam List seq a list
      -- @return the list
    1 function List:slice_assign(i1,i2,seq)
****0     assert_arg(1,i1,'number')
****0     assert_arg(1,i2,'number')
****0     i1,i2 = normalize_slice(self,i1,i2)
****0     if i2 >= i1 then self:chop(i1,i2) end
****0     self:splice(i1,seq)
****0     return self
      end

      --- Concatenation operator.
      -- @within metamethods
      -- @tparam List L another List
      -- @return a new list consisting of the list with the elements of the new list appended
    1 function List:__concat(L)
****0     assert_arg(1,L,'table')
****0     local ls = self:clone()
****0     ls:extend(L)
****0     return ls
      end

      --- Equality operator ==.  True iff all elements of two lists are equal.
      -- @within metamethods
      -- @tparam List L another List
      -- @return true or false
    1 function List:__eq(L)
****0     if #self ~= #L then return false end
****0     for i = 1,#self do
****0         if self[i] ~= L[i] then return false end
          end
****0     return true
      end

      --- Join the elements of a list using a delimiter.
      -- This method uses tostring on all elements.
      -- @string[opt=''] delim a delimiter string, can be empty.
      -- @return a string
    1 function List:join (delim)
****0     delim = delim or ''
****0     assert_arg(1,delim,'string')
****0     return concat(array_tostring(self),delim)
      end

      --- Join a list of strings. <br>
      -- Uses `table.concat` directly.
      -- @function List:concat
      -- @string[opt=''] delim a delimiter
      -- @return a string
    1 List.concat = concat

      local function tostring_q(val)
****0     local s = tostring(val)
****0     if type(val) == 'string' then
****0         s = '"'..s..'"'
          end
****0     return s
      end

      --- How our list should be rendered as a string. Uses join().
      -- @within metamethods
      -- @see List:join
    1 function List:__tostring()
****0     return '{'..self:join(',',tostring_q)..'}'
      end

      --- Call the function on each element of the list.
      -- @func fun a function or callable object
      -- @param ... optional values to pass to function
    1 function List:foreach (fun,...)
****0     fun = function_arg(1,fun)
****0     for i = 1,#self do
****0         fun(self[i],...)
          end
      end

      local function lookup_fun (obj,name)
****0     local f = obj[name]
****0     if not f then error(type(obj).." does not have method "..name,3) end
****0     return f
      end

      --- Call the named method on each element of the list.
      -- @string name the method name
      -- @param ... optional values to pass to function
    1 function List:foreachm (name,...)
****0     for i = 1,#self do
****0         local obj = self[i]
****0         local f = lookup_fun(obj,name)
****0         f(obj,...)
          end
      end

      --- Create a list of all elements which match a function.
      -- @func fun a boolean function
      -- @param[opt] arg optional argument to be passed as second argument of the predicate
      -- @return a new filtered list.
    1 function List:filter (fun,arg)
****0     return makelist(filter(self,fun,arg),self)
      end

      --- Split a string using a delimiter.
      -- @string s the string
      -- @string[opt] delim the delimiter (default spaces)
      -- @return a List of strings
      -- @see pl.utils.split
    1 function List.split (s,delim)
****0     assert_arg(1,s,'string')
****0     return makelist(split(s,delim))
      end

      --- Apply a function to all elements.
      -- Any extra arguments will be passed to the function.
      -- @func fun a function of at least one argument
      -- @param ... arbitrary extra arguments.
      -- @return a new list: {f(x) for x in self}
      -- @usage List{'one','two'}:map(string.upper) == {'ONE','TWO'}
      -- @see pl.tablex.imap
    1 function List:map (fun,...)
****0     return makelist(imap(fun,self,...),self)
      end

      --- Apply a function to all elements, in-place.
      -- Any extra arguments are passed to the function.
      -- @func fun A function that takes at least one argument
      -- @param ... arbitrary extra arguments.
      -- @return the list.
    1 function List:transform (fun,...)
****0     transform(fun,self,...)
****0     return self
      end

      --- Apply a function to elements of two lists.
      -- Any extra arguments will be passed to the function
      -- @func fun a function of at least two arguments
      -- @tparam List ls another list
      -- @param ... arbitrary extra arguments.
      -- @return a new list: {f(x,y) for x in self, for x in arg1}
      -- @see pl.tablex.imap2
    1 function List:map2 (fun,ls,...)
****0     return makelist(imap2(fun,self,ls,...),self)
      end

      --- apply a named method to all elements.
      -- Any extra arguments will be passed to the method.
      -- @string name name of method
      -- @param ... extra arguments
      -- @return a new list of the results
      -- @see pl.seq.mapmethod
    1 function List:mapm (name,...)
****0     local res = {}
****0     for i = 1,#self do
****0       local val = self[i]
****0       local fn = lookup_fun(val,name)
****0       res[i] = fn(val,...)
          end
****0     return makelist(res,self)
      end

      local function composite_call (method,f)
          return function(self,...)
****0         return self[method](self,f,...)
          end
      end

    1 function List.default_map_with(T)
          return function(self,name)
              local m
****0         if T then
****0             local f = lookup_fun(T,name)
****0             m = composite_call('map',f)
              else
****0             m = composite_call('mapn',name)
              end
****0         getmetatable(self)[name] = m -- and cache..
****0         return m
          end
      end

    1 List.default_map = List.default_map_with

      --- 'reduce' a list using a binary function.
      -- @func fun a function of two arguments
      -- @return result of the function
      -- @see pl.tablex.reduce
    1 function List:reduce (fun)
****0     return reduce(fun,self)
      end

      --- Partition a list using a classifier function.
      -- The function may return nil, but this will be converted to the string key '<nil>'.
      -- @func fun a function of at least one argument
      -- @param ... will also be passed to the function
      -- @treturn MultiMap a table where the keys are the returned values, and the values are Lists
      -- of values where the function returned that key.
      -- @see pl.MultiMap
    1 function List:partition (fun,...)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     for i = 1,#self do
****0         local val = self[i]
****0         local klass = fun(val,...)
****0         if klass == nil then klass = '<nil>' end
****0         if not res[klass] then res[klass] = List() end
****0         res[klass]:append(val)
          end
****0     return setmetatable(res,Multimap)
      end

      --- return an iterator over all values.
    1 function List:iter ()
****0     return iter(self)
      end

      --- Create an iterator over a seqence.
      -- This captures the Python concept of 'sequence'.
      -- For tables, iterates over all values with integer indices.
      -- @param seq a sequence; a string (over characters), a table, a file object (over lines) or an iterator function
      -- @usage for x in iterate {1,10,22,55} do io.write(x,',') end ==> 1,10,22,55
      -- @usage for ch in iterate 'help' do do io.write(ch,' ') end ==> h e l p
    1 function List.iterate(seq)
****0     if type(seq) == 'string' then
****0         local idx = 0
****0         local n = #seq
****0         local sub = string.sub
              return function ()
****0             idx = idx + 1
****0             if idx > n then return nil
                  else
****0                 return sub(seq,idx,idx)
                  end
              end
****0     elseif type(seq) == 'table' then
****0         local idx = 0
****0         local n = #seq
              return function()
****0             idx = idx + 1
****0             if idx > n then return nil
                  else
****0                 return seq[idx]
                  end
              end
****0     elseif type(seq) == 'function' then
****0         return seq
****0     elseif type(seq) == 'userdata' and io.type(seq) == 'file' then
****0         return seq:lines()
          end
      end
    1 iter = List.iterate

    1 return List


==============================================================================
/usr/local/share/lua/5.3/pl/class.lua
==============================================================================
      --- Provides a reuseable and convenient framework for creating classes in Lua.
      -- Two possible notations:
      --
      --    B = class(A)
      --    class.B(A)
      --
      -- The latter form creates a named class within the current environment. Note
      -- that this implicitly brings in `pl.utils` as a dependency.
      --
      -- See the Guide for further @{01-introduction.md.Simplifying_Object_Oriented_Programming_in_Lua|discussion}
      -- @module pl.class

      local error, getmetatable, io, pairs, rawget, rawset, setmetatable, tostring, type =
****0     _G.error, _G.getmetatable, _G.io, _G.pairs, _G.rawget, _G.rawset, _G.setmetatable, _G.tostring, _G.type
      local compat

      -- this trickery is necessary to prevent the inheritance of 'super' and
      -- the resulting recursive call problems.
      local function call_ctor (c,obj,...)
****0     local init = rawget(c,'_init')
****0     local parent_with_init = rawget(c,'_parent_with_init')

****0     if parent_with_init then
****0         if not init then -- inheriting an init
****0             init = rawget(parent_with_init, '_init')
****0             parent_with_init = rawget(parent_with_init, '_parent_with_init')
              end
****0         if parent_with_init then -- super() points to one above whereever _init came from
****0             rawset(obj,'super',function(obj,...)
****0                 call_ctor(parent_with_init,obj,...)
                  end)
              end
          else
              -- Without this, calling super() where none exists will sometimes loop and stack overflow
****0         rawset(obj,'super',nil)
          end

****0     local res = init(obj,...)
****0     if parent_with_init then -- If this execution of call_ctor set a super, unset it
****0         rawset(obj,'super',nil)
          end

****0     return res
      end

      --- initializes an __instance__ upon creation.
      -- @function class:_init
      -- @param ... parameters passed to the constructor
      -- @usage local Cat = class()
      -- function Cat:_init(name)
      --   --self:super(name)   -- call the ancestor initializer if needed
      --   self.name = name
      -- end
      --
      -- local pussycat = Cat("pussycat")
      -- print(pussycat.name)  --> pussycat

      --- checks whether an __instance__ is derived from some class.
      -- Works the other way around as `class_of`. It has two ways of using;
      -- 1) call with a class to check against, 2) call without params.
      -- @function instance:is_a
      -- @param some_class class to check against, or `nil` to return the class
      -- @return `true` if `instance` is derived from `some_class`, or if `some_class == nil` then
      -- it returns the class table of the instance
      -- @usage local pussycat = Lion()  -- assuming Lion derives from Cat
      -- if pussycat:is_a(Cat) then
      --   -- it's true, it is a Lion, but also a Cat
      -- end
      --
      -- if pussycat:is_a() == Lion then
      --   -- It's true
      -- end
      local function is_a(self,klass)
****0     if klass == nil then
              -- no class provided, so return the class this instance is derived from
****0         return getmetatable(self)
          end
****0     local m = getmetatable(self)
****0     if not m then return false end --*can't be an object!
****0     while m do
****0         if m == klass then return true end
****0         m = rawget(m,'_base')
          end
****0     return false
      end

      --- checks whether an __instance__ is derived from some class.
      -- Works the other way around as `is_a`.
      -- @function some_class:class_of
      -- @param some_instance instance to check against
      -- @return `true` if `some_instance` is derived from `some_class`
      -- @usage local pussycat = Lion()  -- assuming Lion derives from Cat
      -- if Cat:class_of(pussycat) then
      --   -- it's true
      -- end
      local function class_of(klass,obj)
****0     if type(klass) ~= 'table' or not rawget(klass,'is_a') then return false end
****0     return klass.is_a(obj,klass)
      end

      --- cast an object to another class.
      -- It is not clever (or safe!) so use carefully.
      -- @param some_instance the object to be changed
      -- @function some_class:cast
      local function cast (klass, obj)
****0     return setmetatable(obj,klass)
      end


      local function _class_tostring (obj)
****0     local mt = obj._class
****0     local name = rawget(mt,'_name')
****0     setmetatable(obj,nil)
****0     local str = tostring(obj)
****0     setmetatable(obj,mt)
****0     if name then str = name ..str:gsub('table','') end
****0     return str
      end

      local function tupdate(td,ts,dont_override)
****0     for k,v in pairs(ts) do
****0         if not dont_override or td[k] == nil then
****0             td[k] = v
              end
          end
      end

      local function _class(base,c_arg,c)
          -- the class `c` will be the metatable for all its objects,
          -- and they will look up their methods in it.
    1     local mt = {}   -- a metatable for the class to support __call and _handler
          -- can define class by passing it a plain table of methods
    1     local plain = type(base) == 'table' and not getmetatable(base)
    1     if plain then
****0         c = base
****0         base = c._base
          else
    1         c = c or {}
          end

    1     if type(base) == 'table' then
              -- our new class is a shallow copy of the base class!
              -- but be careful not to wipe out any methods we have been given at this point!
****0         tupdate(c,base,plain)
****0         c._base = base
              -- inherit the 'not found' handler, if present
****0         if rawget(c,'_handler') then mt.__index = c._handler end
    1     elseif base ~= nil then
****0         error("must derive from a table type",3)
          end

    1     c.__index = c
    1     setmetatable(c,mt)
    1     if not plain then
    1         if base and rawget(base,'_init') then c._parent_with_init = base end -- For super and inherited init
    1         c._init = nil
          end

    1     if base and rawget(base,'_class_init') then
****0         base._class_init(c,c_arg)
          end

          -- expose a ctor which can be called by <classname>(<args>)
          mt.__call = function(class_tbl,...)
              local obj
****0         if rawget(c,'_create') then obj = c._create(...) end
****0         if not obj then obj = {} end
****0         setmetatable(obj,c)

****0         if rawget(c,'_init') or rawget(c,'_parent_with_init') then -- constructor exists
****0             local res = call_ctor(c,obj,...)
****0             if res then -- _if_ a ctor returns a value, it becomes the object...
****0                 obj = res
****0                 setmetatable(obj,c)
                  end
              end

****0         if base and rawget(base,'_post_init') then
****0             base._post_init(obj)
              end

****0         return obj
          end
          -- Call Class.catch to set a handler for methods/properties not found in the class!
          c.catch = function(self, handler)
****0         if type(self) == "function" then
                  -- called using . instead of :
****0             handler = self
              end
****0         c._handler = handler
****0         mt.__index = handler
          end
    1     c.is_a = is_a
    1     c.class_of = class_of
    1     c.cast = cast
    1     c._class = c

    1     if not rawget(c,'__tostring') then
    1         c.__tostring = _class_tostring
          end

    1     return c
      end

      --- create a new class, derived from a given base class.
      -- Supporting two class creation syntaxes:
      -- either `Name = class(base)` or `class.Name(base)`.
      -- The first form returns the class directly and does not set its `_name`.
      -- The second form creates a variable `Name` in the current environment set
      -- to the class, and also sets `_name`.
      -- @function class
      -- @param base optional base class
      -- @param c_arg optional parameter to class constructor
      -- @param c optional table to be used as class
      local class
****0 class = setmetatable({},{
          __call = function(fun,...)
    1         return _class(...)
          end,
          __index = function(tbl,key)
****0         if key == 'class' then
****0             io.stderr:write('require("pl.class").class is deprecated. Use require("pl.class")\n')
****0             return class
              end
****0         compat = compat or require 'pl.compat'
****0         local env = compat.getfenv(2)
              return function(...)
****0             local c = _class(...)
****0             c._name = key
****0             rawset(env,key,c)
****0             return c
              end
          end
      })

****0 class.properties = class()

****0 function class.properties._class_init(klass)
          klass.__index = function(t,key)
              -- normal class lookup!
****0         local v = klass[key]
****0         if v then return v end
              -- is it a getter?
****0         v = rawget(klass,'get_'..key)
****0         if v then
****0             return v(t)
              end
              -- is it a field?
****0         return rawget(t,'_'..key)
          end
          klass.__newindex = function (t,key,value)
              -- if there's a setter, use that, otherwise directly set table
****0         local p = 'set_'..key
****0         local setter = klass[p]
****0         if setter then
****0             setter(t,value)
              else
****0             rawset(t,key,value)
              end
          end
      end


****0 return class


==============================================================================
/usr/local/share/lua/5.3/pl/dir.lua
==============================================================================
      --- Listing files in directories and creating/removing directory paths.
      --
      -- Dependencies: `pl.utils`, `pl.path`
      --
      -- Soft Dependencies: `alien`, `ffi` (either are used on Windows for copying/moving files)
      -- @module pl.dir

    1 local utils = require 'pl.utils'
    1 local path = require 'pl.path'
    1 local is_windows = path.is_windows
    1 local ldir = path.dir
    1 local mkdir = path.mkdir
    1 local rmdir = path.rmdir
    1 local sub = string.sub
    1 local os,pcall,ipairs,pairs,require,setmetatable = os,pcall,ipairs,pairs,require,setmetatable
    1 local remove = os.remove
    1 local append = table.insert
    1 local assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise

    1 local exists, isdir = path.exists, path.isdir
    1 local sep = path.sep

    1 local dir = {}

      local function makelist(l)
    1     return setmetatable(l, require('pl.List'))
      end

      local function assert_dir (n,val)
    1     assert_arg(n,val,'string',path.isdir,'not a directory',4)
      end

      local function filemask(mask)
    3     mask = utils.escape(path.normcase(mask))
    3     return '^'..mask:gsub('%%%*','.*'):gsub('%%%?','.')..'$'
      end

      --- Test whether a file name matches a shell pattern.
      -- Both parameters are case-normalized if operating system is
      -- case-insensitive.
      -- @string filename A file name.
      -- @string pattern A shell pattern. The only special characters are
      -- `'*'` and `'?'`: `'*'` matches any sequence of characters and
      -- `'?'` matches any single character.
      -- @treturn bool
      -- @raise dir and mask must be strings
    1 function dir.fnmatch(filename,pattern)
****0     assert_string(1,filename)
****0     assert_string(2,pattern)
****0     return path.normcase(filename):find(filemask(pattern)) ~= nil
      end

      --- Return a list of all file names within an array which match a pattern.
      -- @tab filenames An array containing file names.
      -- @string pattern A shell pattern.
      -- @treturn List(string) List of matching file names.
      -- @raise dir and mask must be strings
    1 function dir.filter(filenames,pattern)
****0     assert_arg(1,filenames,'table')
****0     assert_string(2,pattern)
****0     local res = {}
****0     local mask = filemask(pattern)
****0     for i,f in ipairs(filenames) do
****0         if path.normcase(f):find(mask) then append(res,f) end
          end
****0     return makelist(res)
      end

      local function _listfiles(dirname,filemode,match)
****0     local res = {}
****0     local check = utils.choose(filemode,path.isfile,path.isdir)
****0     if not dirname then dirname = '.' end
****0     for f in ldir(dirname) do
****0         if f ~= '.' and f ~= '..' then
****0             local p = path.join(dirname,f)
****0             if check(p) and (not match or match(f)) then
****0                 append(res,p)
                  end
              end
          end
****0     return makelist(res)
      end

      --- return a list of all files in a directory which match a shell pattern.
      -- @string dirname A directory. If not given, all files in current directory are returned.
      -- @string mask  A shell pattern. If not given, all files are returned.
      -- @treturn {string} list of files
      -- @raise dirname and mask must be strings
    1 function dir.getfiles(dirname,mask)
****0     assert_dir(1,dirname)
****0     if mask then assert_string(2,mask) end
          local match
****0     if mask then
****0         mask = filemask(mask)
              match = function(f)
****0             return path.normcase(f):find(mask)
              end
          end
****0     return _listfiles(dirname,true,match)
      end

      --- return a list of all subdirectories of the directory.
      -- @string dirname A directory
      -- @treturn {string} a list of directories
      -- @raise dir must be a a valid directory
    1 function dir.getdirectories(dirname)
****0     assert_dir(1,dirname)
****0     return _listfiles(dirname,false)
      end

      local alien,ffi,ffi_checked,CopyFile,MoveFile,GetLastError,win32_errors,cmd_tmpfile

      local function execute_command(cmd,parms)
****0    if not cmd_tmpfile then cmd_tmpfile = path.tmpname () end
****0    local err = path.is_windows and ' > ' or ' 2> '
****0     cmd = cmd..' '..parms..err..utils.quote_arg(cmd_tmpfile)
****0     local ret = utils.execute(cmd)
****0     if not ret then
****0         local err = (utils.readfile(cmd_tmpfile):gsub('\n(.*)',''))
****0         remove(cmd_tmpfile)
****0         return false,err
          else
****0         remove(cmd_tmpfile)
****0         return true
          end
      end

      local function find_ffi_copyfile ()
****0     if not ffi_checked then
****0         ffi_checked = true
              local res
****0         res,alien = pcall(require,'alien')
****0         if not res then
****0             alien = nil
****0             res, ffi = pcall(require,'ffi')
              end
****0         if not res then
****0             ffi = nil
****0             return
              end
          else
****0         return
          end
****0     if alien then
              -- register the Win32 CopyFile and MoveFile functions
****0         local kernel = alien.load('kernel32.dll')
****0         CopyFile = kernel.CopyFileA
****0         CopyFile:types{'string','string','int',ret='int',abi='stdcall'}
****0         MoveFile = kernel.MoveFileA
****0         MoveFile:types{'string','string',ret='int',abi='stdcall'}
****0         GetLastError = kernel.GetLastError
****0         GetLastError:types{ret ='int', abi='stdcall'}
****0     elseif ffi then
****0         ffi.cdef [[
                  int CopyFileA(const char *src, const char *dest, int iovr);
                  int MoveFileA(const char *src, const char *dest);
                  int GetLastError();
****0         ]]
****0         CopyFile = ffi.C.CopyFileA
****0         MoveFile = ffi.C.MoveFileA
****0         GetLastError = ffi.C.GetLastError
          end
****0     win32_errors = {
              ERROR_FILE_NOT_FOUND    =         2,
              ERROR_PATH_NOT_FOUND    =         3,
              ERROR_ACCESS_DENIED    =          5,
              ERROR_WRITE_PROTECT    =          19,
              ERROR_BAD_UNIT         =          20,
              ERROR_NOT_READY        =          21,
              ERROR_WRITE_FAULT      =          29,
              ERROR_READ_FAULT       =          30,
              ERROR_SHARING_VIOLATION =         32,
              ERROR_LOCK_VIOLATION    =         33,
              ERROR_HANDLE_DISK_FULL  =         39,
              ERROR_BAD_NETPATH       =         53,
              ERROR_NETWORK_BUSY      =         54,
              ERROR_DEV_NOT_EXIST     =         55,
              ERROR_FILE_EXISTS       =         80,
              ERROR_OPEN_FAILED       =         110,
              ERROR_INVALID_NAME      =         123,
              ERROR_BAD_PATHNAME      =         161,
              ERROR_ALREADY_EXISTS    =         183,
          }
      end

      local function two_arguments (f1,f2)
****0     return utils.quote_arg(f1)..' '..utils.quote_arg(f2)
      end

      local function file_op (is_copy,src,dest,flag)
****0     if flag == 1 and path.exists(dest) then
****0         return false,"cannot overwrite destination"
          end
****0     if is_windows then
              -- if we haven't tried to load Alien/LuaJIT FFI before, then do so
****0         find_ffi_copyfile()
              -- fallback if there's no Alien, just use DOS commands *shudder*
              -- 'rename' involves a copy and then deleting the source.
****0         if not CopyFile then
****0             if path.is_windows then
****0                 src = src:gsub("/","\\")
****0                 dest = dest:gsub("/","\\")
                  end
****0             local res, err = execute_command('copy',two_arguments(src,dest))
****0             if not res then return false,err end
****0             if not is_copy then
****0                 return execute_command('del',utils.quote_arg(src))
                  end
****0             return true
              else
****0             if path.isdir(dest) then
****0                 dest = path.join(dest,path.basename(src))
                  end
                  local ret
****0             if is_copy then ret = CopyFile(src,dest,flag)
****0             else ret = MoveFile(src,dest) end
****0             if ret == 0 then
****0                 local err = GetLastError()
****0                 for name,value in pairs(win32_errors) do
****0                     if value == err then return false,name end
                      end
****0                 return false,"Error #"..err
****0             else return true
                  end
              end
          else -- for Unix, just use cp for now
****0         return execute_command(is_copy and 'cp' or 'mv',
****0             two_arguments(src,dest))
          end
      end

      --- copy a file.
      -- @string src source file
      -- @string dest destination file or directory
      -- @bool flag true if you want to force the copy (default)
      -- @treturn bool operation succeeded
      -- @raise src and dest must be strings
    1 function dir.copyfile (src,dest,flag)
****0     assert_string(1,src)
****0     assert_string(2,dest)
****0     flag = flag==nil or flag
****0     return file_op(true,src,dest,flag and 0 or 1)
      end

      --- move a file.
      -- @string src source file
      -- @string dest destination file or directory
      -- @treturn bool operation succeeded
      -- @raise src and dest must be strings
    1 function dir.movefile (src,dest)
****0     assert_string(1,src)
****0     assert_string(2,dest)
****0     return file_op(false,src,dest,0)
      end

      local function _dirfiles(dirname,attrib)
****0     local dirs = {}
****0     local files = {}
****0     for f in ldir(dirname) do
****0         if f ~= '.' and f ~= '..' then
****0             local p = path.join(dirname,f)
****0             local mode = attrib(p,'mode')
****0             if mode=='directory' then
****0                 append(dirs,f)
                  else
****0                 append(files,f)
                  end
              end
          end
****0     return makelist(dirs), makelist(files)
      end


      --- return an iterator which walks through a directory tree starting at root.
      -- The iterator returns (root,dirs,files)
      -- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)
      -- to get the actual full path)
      -- If bottom_up is false (or not present), then the entries at the current level are returned
      -- before we go deeper. This means that you can modify the returned list of directories before
      -- continuing.
      -- This is a clone of os.walk from the Python libraries.
      -- @string root A starting directory
      -- @bool bottom_up False if we start listing entries immediately.
      -- @bool follow_links follow symbolic links
      -- @return an iterator returning root,dirs,files
      -- @raise root must be a directory
    1 function dir.walk(root,bottom_up,follow_links)
****0     assert_dir(1,root)
          local attrib
****0     if path.is_windows or not follow_links then
****0         attrib = path.attrib
          else
****0         attrib = path.link_attrib
          end

****0     local to_scan = { root }
****0     local to_return = {}
          local iter = function()
****0         while #to_scan > 0 do
****0             local current_root = table.remove(to_scan)
****0             local dirs,files = _dirfiles(current_root, attrib)
****0             for _, d in ipairs(dirs) do
****0                 table.insert(to_scan, current_root..path.sep..d)
                  end
****0             if not bottom_up then
****0                 return current_root, dirs, files
                  else
****0                 table.insert(to_return, { current_root, dirs, files })
                  end
              end
****0         if #to_return > 0 then
****0             return utils.unpack(table.remove(to_return))
              end
          end

****0     return iter
      end

      --- remove a whole directory tree.
      -- @string fullpath A directory path
      -- @return true or nil
      -- @return error if failed
      -- @raise fullpath must be a string
    1 function dir.rmtree(fullpath)
****0     assert_dir(1,fullpath)
****0     if path.islink(fullpath) then return false,'will not follow symlink' end
****0     for root,dirs,files in dir.walk(fullpath,true) do
****0         for i,f in ipairs(files) do
****0             local res, err = remove(path.join(root,f))
****0             if not res then return nil,err end
              end
****0         local res, err = rmdir(root)
****0         if not res then return nil,err end
          end
****0     return true
      end

      local dirpat
    1 if path.is_windows then
****0     dirpat = '(.+)\\[^\\]+$'
      else
    1     dirpat = '(.+)/[^/]+$'
      end

      local _makepath
    1 function _makepath(p)
          -- windows root drive case
****0     if p:find '^%a:[\\]*$' then
****0         return true
          end
****0    if not path.isdir(p) then
****0     local subp = p:match(dirpat)
****0     local ok, err = _makepath(subp)
****0     if not ok then return nil, err end
****0     return mkdir(p)
         else
****0     return true
         end
      end

      --- create a directory path.
      -- This will create subdirectories as necessary!
      -- @string p A directory path
      -- @return true on success, nil + errormsg on failure
      -- @raise failure to create
    1 function dir.makepath (p)
****0     assert_string(1,p)
****0     if path.is_windows then
****0         p = p:gsub("/", "\\")
          end
****0     return _makepath(path.abspath(p))
      end


      --- clone a directory tree. Will always try to create a new directory structure
      -- if necessary.
      -- @string path1 the base path of the source tree
      -- @string path2 the new base path for the destination
      -- @func file_fun an optional function to apply on all files
      -- @bool verbose an optional boolean to control the verbosity of the output.
      --  It can also be a logging function that behaves like print()
      -- @return true, or nil
      -- @return error message, or list of failed directory creations
      -- @return list of failed file operations
      -- @raise path1 and path2 must be strings
      -- @usage clonetree('.','../backup',copyfile)
    1 function dir.clonetree (path1,path2,file_fun,verbose)
****0     assert_string(1,path1)
****0     assert_string(2,path2)
****0     if verbose == true then verbose = print end
****0     local abspath,normcase,isdir,join = path.abspath,path.normcase,path.isdir,path.join
****0     local faildirs,failfiles = {},{}
****0     if not isdir(path1) then return raise 'source is not a valid directory' end
****0     path1 = abspath(normcase(path1))
****0     path2 = abspath(normcase(path2))
****0     if verbose then verbose('normalized:',path1,path2) end
          -- particularly NB that the new path isn't fully contained in the old path
****0     if path1 == path2 then return raise "paths are the same" end
****0     local _,i2 = path2:find(path1,1,true)
****0     if i2 == #path1 and path2:sub(i2+1,i2+1) == path.sep then
****0         return raise 'destination is a subdirectory of the source'
          end
****0     local cp = path.common_prefix (path1,path2)
****0     local idx = #cp
****0     if idx == 0 then -- no common path, but watch out for Windows paths!
****0         if path1:sub(2,2) == ':' then idx = 3 end
          end
****0     for root,dirs,files in dir.walk(path1) do
****0         local opath = path2..root:sub(idx)
****0         if verbose then verbose('paths:',opath,root) end
****0         if not isdir(opath) then
****0             local ret = dir.makepath(opath)
****0             if not ret then append(faildirs,opath) end
****0             if verbose then verbose('creating:',opath,ret) end
              end
****0         if file_fun then
****0             for i,f in ipairs(files) do
****0                 local p1 = join(root,f)
****0                 local p2 = join(opath,f)
****0                 local ret = file_fun(p1,p2)
****0                 if not ret then append(failfiles,p2) end
****0                 if verbose then
****0                     verbose('files:',p1,p2,ret)
                      end
                  end
              end
          end
****0     return true,faildirs,failfiles
      end


      -- each entry of the stack is an array with three items:
      -- 1. the name of the directory
      -- 2. the lfs iterator function
      -- 3. the lfs iterator userdata
      local function treeiter(iterstack)
    7     local diriter = iterstack[#iterstack]
    7     if not diriter then
    1       return -- done
          end

    6     local dirname = diriter[1]
    6     local entry = diriter[2](diriter[3])
    6     if not entry then
    1       table.remove(iterstack)
    1       return treeiter(iterstack) -- tail-call to try next
          end

    5     if entry ~= "." and entry ~= ".." then
    3         entry = dirname .. sep .. entry
    3         if exists(entry) then  -- Just in case a symlink is broken.
    3             local is_dir = isdir(entry)
    3             if is_dir then
****0                 table.insert(iterstack, { entry, ldir(entry) })
                  end
    3             return entry, is_dir
              end
          end

    2     return treeiter(iterstack) -- tail-call to try next
      end


      --- return an iterator over all entries in a directory tree
      -- @string d a directory
      -- @return an iterator giving pathname and mode (true for dir, false otherwise)
      -- @raise d must be a non-empty string
    1 function dir.dirtree( d )
    1     assert( d and d ~= "", "directory parameter is missing or empty" )

    1     local last = sub ( d, -1 )
    1     if last == sep or last == '/' then
****0         d = sub( d, 1, -2 )
          end

    1     local iterstack = { {d, ldir(d)} }

    1     return treeiter, iterstack
      end


      --- Recursively returns all the file starting at _path_. It can optionally take a shell pattern and
      -- only returns files that match _shell_pattern_. If a pattern is given it will do a case insensitive search.
      -- @string start_path  A directory. If not given, all files in current directory are returned.
      -- @string shell_pattern A shell pattern. If not given, all files are returned.
      -- @treturn List(string) containing all the files found recursively starting at _path_ and filtered by _shell_pattern_.
      -- @raise start_path must be a directory
    1 function dir.getallfiles( start_path, shell_pattern )
    1     assert_dir(1,start_path)
    1     shell_pattern = shell_pattern or "*"

    1     local files = {}
    1     local normcase = path.normcase
    4     for filename, mode in dir.dirtree( start_path ) do
    3         if not mode then
    3             local mask = filemask( shell_pattern )
    3             if normcase(filename):find( mask ) then
    3                 files[#files + 1] = filename
                  end
              end
          end

    1     return makelist(files)
      end

    1 return dir

==============================================================================
/usr/local/share/lua/5.3/pl/path.lua
==============================================================================
      --- Path manipulation and file queries.
      --
      -- This is modelled after Python's os.path library (10.1); see @{04-paths.md|the Guide}.
      --
      -- NOTE: the functions assume the paths being dealt with to originate
      -- from the OS the application is running on. Windows drive letters are not
      -- to be used when running on a Unix system for example. The one exception
      -- is Windows paths to allow both forward and backward slashes (since Lua
      -- also accepts those)
      --
      -- Dependencies: `pl.utils`, `lfs`
      -- @module pl.path

      -- imports and locals
****0 local _G = _G
****0 local sub = string.sub
****0 local getenv = os.getenv
****0 local tmpnam = os.tmpname
****0 local package = package
****0 local append, concat, remove = table.insert, table.concat, table.remove
****0 local utils = require 'pl.utils'
****0 local assert_string,raise = utils.assert_string,utils.raise

****0 local res,lfs = _G.pcall(_G.require,'lfs')
****0 if not res then
****0     error("pl.path requires LuaFileSystem")
      end

****0 local attrib = lfs.attributes
****0 local currentdir = lfs.currentdir
****0 local link_attrib = lfs.symlinkattributes

****0 local path = {}

      --- Lua iterator over the entries of a given directory.
      -- Implicit link to [`luafilesystem.dir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function dir
****0 path.dir = lfs.dir

      --- Creates a directory.
      -- Implicit link to [`luafilesystem.mkdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function mkdir
****0 path.mkdir = lfs.mkdir

      --- Removes a directory.
      -- Implicit link to [`luafilesystem.rmdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function rmdir
****0 path.rmdir = lfs.rmdir

      --- Gets attributes.
      -- Implicit link to [`luafilesystem.attributes`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function attrib
****0 path.attrib = attrib

      --- Get the working directory.
      -- Implicit link to [`luafilesystem.currentdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function currentdir
****0 path.currentdir = currentdir

      --- Gets symlink attributes.
      -- Implicit link to [`luafilesystem.symlinkattributes`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function link_attrib
****0 path.link_attrib = link_attrib

      --- Changes the working directory.
      -- On Windows, if a drive is specified, it also changes the current drive. If
      -- only specifying the drive, it will only switch drive, but not modify the path.
      -- Implicit link to [`luafilesystem.chdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function chdir
****0 path.chdir = lfs.chdir

      --- is this a directory?
      -- @string P A file path
****0 function path.isdir(P)
    5     assert_string(1,P)
    5     if P:match("\\$") then
****0         P = P:sub(1,-2)
          end
    5     return attrib(P,'mode') == 'directory'
      end

      --- is this a file?
      -- @string P A file path
****0 function path.isfile(P)
    1     assert_string(1,P)
    1     return attrib(P,'mode') == 'file'
      end

      -- is this a symbolic link?
      -- @string P A file path
****0 function path.islink(P)
****0     assert_string(1,P)
****0     if link_attrib then
****0         return link_attrib(P,'mode')=='link'
          else
****0         return false
          end
      end

      --- return size of a file.
      -- @string P A file path
****0 function path.getsize(P)
****0     assert_string(1,P)
****0     return attrib(P,'size')
      end

      --- does a path exist?
      -- @string P A file path
      -- @return the file path if it exists (either as file, directory, socket, etc), nil otherwise
****0 function path.exists(P)
    3     assert_string(1,P)
    3     return attrib(P,'mode') ~= nil and P
      end

      --- Return the time of last access as the number of seconds since the epoch.
      -- @string P A file path
****0 function path.getatime(P)
****0     assert_string(1,P)
****0     return attrib(P,'access')
      end

      --- Return the time of last modification as the number of seconds since the epoch.
      -- @string P A file path
****0 function path.getmtime(P)
****0     assert_string(1,P)
****0     return attrib(P,'modification')
      end

      ---Return the system's ctime as the number of seconds since the epoch.
      -- @string P A file path
****0 function path.getctime(P)
****0     assert_string(1,P)
****0     return path.attrib(P,'change')
      end


      local function at(s,i)
  654     return sub(s,i,i)
      end

****0 path.is_windows = utils.is_windows

      local sep, other_sep, seps
      -- constant sep is the directory separator for this platform.
      -- constant dirsep is the separator in the PATH environment variable
****0 if path.is_windows then
****0     path.sep = '\\'; other_sep = '/'
****0     path.dirsep = ';'
****0     seps = { ['/'] = true, ['\\'] = true }
      else
****0     path.sep = '/'
****0     path.dirsep = ':'
****0     seps = { ['/'] = true }
      end
****0 sep = path.sep

      --- are we running Windows?
      -- @class field
      -- @name path.is_windows

      --- path separator for this platform.
      -- @class field
      -- @name path.sep

      --- separator for PATH for this platform
      -- @class field
      -- @name path.dirsep

      --- given a path, return the directory part and a file part.
      -- if there's no directory part, the first value will be empty
      -- @string P A file path
      -- @return directory part
      -- @return file part
      -- @usage
      -- local dir, file = path.splitpath("some/dir/myfile.txt")
      -- assert(dir == "some/dir")
      -- assert(file == "myfile.txt")
      --
      -- local dir, file = path.splitpath("some/dir/")
      -- assert(dir == "some/dir")
      -- assert(file == "")
      --
      -- local dir, file = path.splitpath("some_dir")
      -- assert(dir == "")
      -- assert(file == "some_dir")
****0 function path.splitpath(P)
   51     assert_string(1,P)
   51     local i = #P
   51     local ch = at(P,i)
  646     while i > 0 and ch ~= sep and ch ~= other_sep do
  595         i = i - 1
  595         ch = at(P,i)
          end
   51     if i == 0 then
****0         return '',P
          else
   51         return sub(P,1,i-1), sub(P,i+1)
          end
      end

      --- return an absolute path.
      -- @string P A file path
      -- @string[opt] pwd optional start path to use (default is current dir)
****0 function path.abspath(P,pwd)
****0     assert_string(1,P)
****0     if pwd then assert_string(2,pwd) end
****0     local use_pwd = pwd ~= nil
****0     if not use_pwd and not currentdir then return P end
****0     P = P:gsub('[\\/]$','')
****0     pwd = pwd or currentdir()
****0     if not path.isabs(P) then
****0         P = path.join(pwd,P)
****0     elseif path.is_windows and not use_pwd and at(P,2) ~= ':' and at(P,2) ~= '\\' then
****0         P = pwd:sub(1,2)..P -- attach current drive to path like '\\fred.txt'
          end
****0     return path.normpath(P)
      end

      --- given a path, return the root part and the extension part.
      -- if there's no extension part, the second value will be empty
      -- @string P A file path
      -- @treturn string root part (everything upto the "."", maybe empty)
      -- @treturn string extension part (including the ".", maybe empty)
      -- @usage
      -- local file_path, ext = path.splitext("/bonzo/dog_stuff/cat.txt")
      -- assert(file_path == "/bonzo/dog_stuff/cat")
      -- assert(ext == ".txt")
      --
      -- local file_path, ext = path.splitext("")
      -- assert(file_path == "")
      -- assert(ext == "")
****0 function path.splitext(P)
    2     assert_string(1,P)
    2     local i = #P
    2     local ch = at(P,i)
    8     while i > 0 and ch ~= '.' do
    6         if seps[ch] then
****0             return P,''
              end
    6         i = i - 1
    6         ch = at(P,i)
          end
    2     if i == 0 then
****0         return P,''
          else
    2         return sub(P,1,i-1),sub(P,i)
          end
      end

      --- return the directory part of a path
      -- @string P A file path
      -- @treturn string everything before the last dir-separator
      -- @see splitpath
      -- @usage
      -- path.dirname("/some/path/file.txt")   -- "/some/path"
      -- path.dirname("file.txt")              -- "" (empty string)
****0 function path.dirname(P)
   48     assert_string(1,P)
   48     local p1 = path.splitpath(P)
   48     return p1
      end

      --- return the file part of a path
      -- @string P A file path
      -- @treturn string
      -- @see splitpath
      -- @usage
      -- path.basename("/some/path/file.txt")  -- "file.txt"
      -- path.basename("/some/path/file/")     -- "" (empty string)
****0 function path.basename(P)
    3     assert_string(1,P)
    3     local _,p2 = path.splitpath(P)
    3     return p2
      end

      --- get the extension part of a path.
      -- @string P A file path
      -- @treturn string
      -- @see splitext
      -- @usage
      -- path.extension("/some/path/file.txt") -- ".txt"
      -- path.extension("/some/path/file_txt") -- "" (empty string)
****0 function path.extension(P)
    2     assert_string(1,P)
    2     local _,p2 = path.splitext(P)
    2     return p2
      end

      --- is this an absolute path?
      -- @string P A file path
      -- @usage
      -- path.isabs("hello/path")    -- false
      -- path.isabs("/hello/path")   -- true
      -- -- Windows;
      -- path.isabs("hello\path")    -- false
      -- path.isabs("\hello\path")   -- true
      -- path.isabs("C:\hello\path") -- true
      -- path.isabs("C:hello\path")  -- false
****0 function path.isabs(P)
****0     assert_string(1,P)
****0     if path.is_windows and at(P,2) == ":" then
****0         return seps[at(P,3)] ~= nil
          end
****0     return seps[at(P,1)] ~= nil
      end

      --- return the path resulting from combining the individual paths.
      -- if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).
      -- empty elements (except the last) will be ignored.
      -- @string p1 A file path
      -- @string p2 A file path
      -- @string ... more file paths
      -- @treturn string the combined path
      -- @usage
      -- path.join("/first","second","third")   -- "/first/second/third"
      -- path.join("first","second/third")      -- "first/second/third"
      -- path.join("/first","/second","third")  -- "/second/third"
****0 function path.join(p1,p2,...)
****0     assert_string(1,p1)
****0     assert_string(2,p2)
****0     if select('#',...) > 0 then
****0         local p = path.join(p1,p2)
****0         local args = {...}
****0         for i = 1,#args do
****0             assert_string(i,args[i])
****0             p = path.join(p,args[i])
              end
****0         return p
          end
****0     if path.isabs(p2) then return p2 end
****0     local endc = at(p1,#p1)
****0     if endc ~= path.sep and endc ~= other_sep and endc ~= "" then
****0         p1 = p1..path.sep
          end
****0     return p1..p2
      end

      --- normalize the case of a pathname. On Unix, this returns the path unchanged,
      -- for Windows it converts;
      --
      -- * the path to lowercase
      -- * forward slashes to backward slashes
      -- @string P A file path
      -- @usage path.normcase("/Some/Path/File.txt")
      -- -- Windows: "\some\path\file.txt"
      -- -- Others : "/Some/Path/File.txt"
****0 function path.normcase(P)
    6     assert_string(1,P)
    6     if path.is_windows then
****0         return P:gsub('/','\\'):lower()
          else
    6         return P
          end
      end

      --- normalize a path name.
      -- `A//B`, `A/./B`, and `A/foo/../B` all become `A/B`.
      --
      -- An empty path results in '.'.
      -- @string P a file path
****0 function path.normpath(P)
****0     assert_string(1,P)
          -- Split path into anchor and relative path.
****0     local anchor = ''
****0     if path.is_windows then
****0         if P:match '^\\\\' then -- UNC
****0             anchor = '\\\\'
****0             P = P:sub(3)
****0         elseif seps[at(P, 1)] then
****0             anchor = '\\'
****0             P = P:sub(2)
****0         elseif at(P, 2) == ':' then
****0             anchor = P:sub(1, 2)
****0             P = P:sub(3)
****0             if seps[at(P, 1)] then
****0                 anchor = anchor..'\\'
****0                 P = P:sub(2)
                  end
              end
****0         P = P:gsub('/','\\')
          else
              -- According to POSIX, in path start '//' and '/' are distinct,
              -- but '///+' is equivalent to '/'.
****0         if P:match '^//' and at(P, 3) ~= '/' then
****0             anchor = '//'
****0             P = P:sub(3)
****0         elseif at(P, 1) == '/' then
****0             anchor = '/'
****0             P = P:match '^/*(.*)$'
              end
          end
****0     local parts = {}
****0     for part in P:gmatch('[^'..sep..']+') do
****0         if part == '..' then
****0             if #parts ~= 0 and parts[#parts] ~= '..' then
****0                 remove(parts)
                  else
****0                 append(parts, part)
                  end
****0         elseif part ~= '.' then
****0             append(parts, part)
              end
          end
****0     P = anchor..concat(parts, sep)
****0     if P == '' then P = '.' end
****0     return P
      end

      --- relative path from current directory or optional start point
      -- @string P a path
      -- @string[opt] start optional start point (default current directory)
****0 function path.relpath (P,start)
****0     assert_string(1,P)
****0     if start then assert_string(2,start) end
****0     local split,min,append = utils.split, math.min, table.insert
****0     P = path.abspath(P,start)
****0     start = start or currentdir()
          local compare
****0     if path.is_windows then
****0         P = P:gsub("/","\\")
****0         start = start:gsub("/","\\")
****0         compare = function(v) return v:lower() end
          else
****0         compare = function(v) return v end
          end
****0     local startl, Pl = split(start,sep), split(P,sep)
****0     local n = min(#startl,#Pl)
****0     if path.is_windows and n > 0 and at(Pl[1],2) == ':' and Pl[1] ~= startl[1] then
****0         return P
          end
****0     local k = n+1 -- default value if this loop doesn't bail out!
****0     for i = 1,n do
****0         if compare(startl[i]) ~= compare(Pl[i]) then
****0             k = i
                  break
              end
          end
****0     local rell = {}
****0     for i = 1, #startl-k+1 do rell[i] = '..' end
****0     if k <= #Pl then
****0         for i = k,#Pl do append(rell,Pl[i]) end
          end
****0     return table.concat(rell,sep)
      end


      --- Replace a starting '~' with the user's home directory.
      -- In windows, if HOME isn't set, then USERPROFILE is used in preference to
      -- HOMEDRIVE HOMEPATH. This is guaranteed to be writeable on all versions of Windows.
      -- @string P A file path
****0 function path.expanduser(P)
****0     assert_string(1,P)
****0     if at(P,1) == '~' then
****0         local home = getenv('HOME')
****0         if not home then -- has to be Windows
****0             home = getenv 'USERPROFILE' or (getenv 'HOMEDRIVE' .. getenv 'HOMEPATH')
              end
****0         return home..sub(P,2)
          else
****0         return P
          end
      end


      ---Return a suitable full path to a new temporary file name.
      -- unlike os.tmpname(), it always gives you a writeable path (uses TEMP environment variable on Windows)
****0 function path.tmpname ()
****0     local res = tmpnam()
          -- On Windows if Lua is compiled using MSVC14 os.tmpname
          -- already returns an absolute path within TEMP env variable directory,
          -- no need to prepend it.
****0     if path.is_windows and not res:find(':') then
****0         res = getenv('TEMP')..res
          end
****0     return res
      end

      --- return the largest common prefix path of two paths.
      -- @string path1 a file path
      -- @string path2 a file path
      -- @return the common prefix (Windows: separators will be normalized, casing will be original)
****0 function path.common_prefix (path1,path2)
****0     assert_string(1,path1)
****0     assert_string(2,path2)
          -- get them in order!
****0     if #path1 > #path2 then path2,path1 = path1,path2 end
          local compare
****0     if path.is_windows then
****0         path1 = path1:gsub("/", "\\")
****0         path2 = path2:gsub("/", "\\")
****0         compare = function(v) return v:lower() end
          else
****0         compare = function(v) return v end
          end
****0     for i = 1,#path1 do
****0         if compare(at(path1,i)) ~= compare(at(path2,i)) then
****0             local cp = path1:sub(1,i-1)
****0             if at(path1,i-1) ~= sep then
****0                 cp = path.dirname(cp)
                  end
****0             return cp
              end
          end
****0     if at(path2,#path1+1) ~= sep then path1 = path.dirname(path1) end
****0     return path1
          --return ''
      end

      --- return the full path where a particular Lua module would be found.
      -- Both package.path and package.cpath is searched, so the result may
      -- either be a Lua file or a shared library.
      -- @string mod name of the module
      -- @return on success: path of module, lua or binary
      -- @return on error: nil, error string listing paths tried
****0 function path.package_path(mod)
****0     assert_string(1,mod)
          local res, err1, err2
****0     res, err1 = package.searchpath(mod,package.path)
****0     if res then return res,true end
****0     res, err2 = package.searchpath(mod,package.cpath)
****0     if res then return res,false end
****0     return raise ('cannot find module on path\n' .. err1 .. "\n" .. err2)
      end


      ---- finis -----
****0 return path

==============================================================================
/usr/local/share/lua/5.3/pl/tablex.lua
==============================================================================
      --- Extended operations on Lua tables.
      --
      -- See @{02-arrays.md.Useful_Operations_on_Tables|the Guide}
      --
      -- Dependencies: `pl.utils`, `pl.types`
      -- @module pl.tablex
****0 local utils = require ('pl.utils')
****0 local types = require ('pl.types')
****0 local getmetatable,setmetatable,require = getmetatable,setmetatable,require
****0 local tsort,append,remove = table.sort,table.insert,table.remove
****0 local min = math.min
****0 local pairs,type,unpack,select,tostring = pairs,type,utils.unpack,select,tostring
****0 local function_arg = utils.function_arg
****0 local assert_arg = utils.assert_arg

****0 local tablex = {}

      -- generally, functions that make copies of tables try to preserve the metatable.
      -- However, when the source has no obvious type, then we attach appropriate metatables
      -- like List, Map, etc to the result.
      local function setmeta (res,tbl,pl_class)
    2     local mt = getmetatable(tbl) or pl_class and require('pl.' .. pl_class)
    2     return mt and setmetatable(res, mt) or res
      end

      local function makelist(l)
****0     return setmetatable(l, require('pl.List'))
      end

      local function makemap(m)
****0     return setmetatable(m, require('pl.Map'))
      end

      local function complain (idx,msg)
****0     error(('argument %d is not %s'):format(idx,msg),3)
      end

      local function assert_arg_indexable (idx,val)
    2     if not types.is_indexable(val) then
****0         complain(idx,"indexable")
          end
      end

      local function assert_arg_iterable (idx,val)
    3     if not types.is_iterable(val) then
****0         complain(idx,"iterable")
          end
      end

      local function assert_arg_writeable (idx,val)
****0     if not types.is_writeable(val) then
****0         complain(idx,"writeable")
          end
      end

      --- copy a table into another, in-place.
      -- @within Copying
      -- @tab t1 destination table
      -- @tab t2 source (actually any iterable object)
      -- @return first table
****0 function tablex.update (t1,t2)
****0     assert_arg_writeable(1,t1)
****0     assert_arg_iterable(2,t2)
****0     for k,v in pairs(t2) do
****0         t1[k] = v
          end
****0     return t1
      end

      --- total number of elements in this table.
      -- Note that this is distinct from `#t`, which is the number
      -- of values in the array part; this value will always
      -- be greater or equal. The difference gives the size of
      -- the hash part, for practical purposes. Works for any
      -- object with a __pairs metamethod.
      -- @tab t a table
      -- @return the size
****0 function tablex.size (t)
****0     assert_arg_iterable(1,t)
****0     local i = 0
****0     for k in pairs(t) do i = i + 1 end
****0     return i
      end

      --- make a shallow copy of a table
      -- @within Copying
      -- @tab t an iterable source
      -- @return new table
****0 function tablex.copy (t)
    3     assert_arg_iterable(1,t)
    3     local res = {}
  189     for k,v in pairs(t) do
  186         res[k] = v
          end
    3     return res
      end

      local function cycle_aware_copy(t, cache)
****0     if type(t) ~= 'table' then return t end
****0     if cache[t] then return cache[t] end
****0     assert_arg_iterable(1,t)
****0     local res = {}
****0     cache[t] = res
****0     local mt = getmetatable(t)
****0     for k,v in pairs(t) do
****0         k = cycle_aware_copy(k, cache)
****0         v = cycle_aware_copy(v, cache)
****0         res[k] = v
          end
****0     setmetatable(res,mt)
****0     return res
      end

      --- make a deep copy of a table, recursively copying all the keys and fields.
      -- This supports cycles in tables; cycles will be reproduced in the copy.
      -- This will also set the copied table's metatable to that of the original.
      -- @within Copying
      -- @tab t A table
      -- @return new table
****0 function tablex.deepcopy(t)
****0     return cycle_aware_copy(t,{})
      end

****0 local abs = math.abs

      local function cycle_aware_compare(t1,t2,ignore_mt,eps,cache)
****0     if cache[t1] and cache[t1][t2] then return true end
****0     local ty1 = type(t1)
****0     local ty2 = type(t2)
****0     if ty1 ~= ty2 then return false end
          -- non-table types can be directly compared
****0     if ty1 ~= 'table' then
****0         if ty1 == 'number' and eps then return abs(t1-t2) < eps end
****0         return t1 == t2
          end
          -- as well as tables which have the metamethod __eq
****0     local mt = getmetatable(t1)
****0     if not ignore_mt and mt and mt.__eq then return t1 == t2 end
****0     for k1 in pairs(t1) do
****0         if t2[k1]==nil then return false end
          end
****0     for k2 in pairs(t2) do
****0         if t1[k2]==nil then return false end
          end
****0     cache[t1] = cache[t1] or {}
****0     cache[t1][t2] = true
****0     for k1,v1 in pairs(t1) do
****0         local v2 = t2[k1]
****0         if not cycle_aware_compare(v1,v2,ignore_mt,eps,cache) then return false end
          end
****0     return true
      end

      --- compare two values.
      -- if they are tables, then compare their keys and fields recursively.
      -- @within Comparing
      -- @param t1 A value
      -- @param t2 A value
      -- @bool[opt] ignore_mt if true, ignore __eq metamethod (default false)
      -- @number[opt] eps if defined, then used for any number comparisons
      -- @return true or false
****0 function tablex.deepcompare(t1,t2,ignore_mt,eps)
****0     return cycle_aware_compare(t1,t2,ignore_mt,eps,{})
      end

      --- compare two arrays using a predicate.
      -- @within Comparing
      -- @array t1 an array
      -- @array t2 an array
      -- @func cmp A comparison function; `bool = cmp(t1_value, t2_value)`
      -- @return true or false
      -- @usage
      -- assert(tablex.compare({ 1, 2, 3 }, { 1, 2, 3 }, "=="))
      --
      -- assert(tablex.compare(
      --    {1,2,3, hello = "world"},  -- fields are not compared!
      --    {1,2,3}, function(v1, v2) return v1 == v2 end)
****0 function tablex.compare (t1,t2,cmp)
****0     assert_arg_indexable(1,t1)
****0     assert_arg_indexable(2,t2)
****0     if #t1 ~= #t2 then return false end
****0     cmp = function_arg(3,cmp)
****0     for k = 1,#t1 do
****0         if not cmp(t1[k],t2[k]) then return false end
          end
****0     return true
      end

      --- compare two list-like tables using an optional predicate, without regard for element order.
      -- @within Comparing
      -- @array t1 a list-like table
      -- @array t2 a list-like table
      -- @param cmp A comparison function (may be nil)
****0 function tablex.compare_no_order (t1,t2,cmp)
****0     assert_arg_indexable(1,t1)
****0     assert_arg_indexable(2,t2)
****0     if cmp then cmp = function_arg(3,cmp) end
****0     if #t1 ~= #t2 then return false end
****0     local visited = {}
****0     for i = 1,#t1 do
****0         local val = t1[i]
              local gotcha
****0         for j = 1,#t2 do
****0             if not visited[j] then
                      local match
****0                 if cmp then match = cmp(val,t2[j]) else match = val == t2[j] end
****0                 if match then
****0                     gotcha = j
                          break
                      end
                  end
              end
****0         if not gotcha then return false end
****0         visited[gotcha] = true
          end
****0     return true
      end


      --- return the index of a value in a list.
      -- Like string.find, there is an optional index to start searching,
      -- which can be negative.
      -- @within Finding
      -- @array t A list-like table
      -- @param val A value
      -- @int idx index to start; -1 means last element,etc (default 1)
      -- @return index of value or nil if not found
      -- @usage find({10,20,30},20) == 2
      -- @usage find({'a','b','a','c'},'a',2) == 3
****0 function tablex.find(t,val,idx)
****0     assert_arg_indexable(1,t)
****0     idx = idx or 1
****0     if idx < 0 then idx = #t + idx + 1 end
****0     for i = idx,#t do
****0         if t[i] == val then return i end
          end
****0     return nil
      end

      --- return the index of a value in a list, searching from the end.
      -- Like string.find, there is an optional index to start searching,
      -- which can be negative.
      -- @within Finding
      -- @array t A list-like table
      -- @param val A value
      -- @param idx index to start; -1 means last element,etc (default `#t`)
      -- @return index of value or nil if not found
      -- @usage rfind({10,10,10},10) == 3
****0 function tablex.rfind(t,val,idx)
****0     assert_arg_indexable(1,t)
****0     idx = idx or #t
****0     if idx < 0 then idx = #t + idx + 1 end
****0     for i = idx,1,-1 do
****0         if t[i] == val then return i end
          end
****0     return nil
      end


      --- return the index (or key) of a value in a table using a comparison function.
      --
      -- *NOTE*: the 2nd return value of this function, the value returned
      -- by the comparison function, has a limitation that it cannot be `false`.
      -- Because if it is, then it indicates the comparison failed, and the
      -- function will continue the search. See examples.
      -- @within Finding
      -- @tab t A table
      -- @func cmp A comparison function
      -- @param arg an optional second argument to the function
      -- @return index of value, or nil if not found
      -- @return value returned by comparison function (cannot be `false`!)
      -- @usage
      -- -- using an operator
      -- local lst = { "Rudolph", true, false, 15 }
      -- local idx, cmp_result = tablex.rfind(lst, "==", "Rudolph")
      -- assert(idx == 1)
      -- assert(cmp_result == true)
      --
      -- local idx, cmp_result = tablex.rfind(lst, "==", false)
      -- assert(idx == 3)
      -- assert(cmp_result == true)       -- looking up 'false' works!
      --
      -- -- using a function returning the value looked up
      -- local cmp = function(v1, v2) return v1 == v2 and v2 end
      -- local idx, cmp_result = tablex.rfind(lst, cmp, "Rudolph")
      -- assert(idx == 1)
      -- assert(cmp_result == "Rudolph")  -- the value is returned
      --
      -- -- NOTE: this fails, since 'false' cannot be returned!
      -- local idx, cmp_result = tablex.rfind(lst, cmp, false)
      -- assert(idx == nil)               -- looking up 'false' failed!
      -- assert(cmp_result == nil)
****0 function tablex.find_if(t,cmp,arg)
****0     assert_arg_iterable(1,t)
****0     cmp = function_arg(2,cmp)
****0     for k,v in pairs(t) do
****0         local c = cmp(v,arg)
****0         if c then return k,c end
          end
****0     return nil
      end

      --- return a list of all values in a table indexed by another list.
      -- @tab tbl a table
      -- @array idx an index table (a list of keys)
      -- @return a list-like table
      -- @usage index_by({10,20,30,40},{2,4}) == {20,40}
      -- @usage index_by({one=1,two=2,three=3},{'one','three'}) == {1,3}
****0 function tablex.index_by(tbl,idx)
****0     assert_arg_indexable(1,tbl)
****0     assert_arg_indexable(2,idx)
****0     local res = {}
****0     for i = 1,#idx do
****0         res[i] = tbl[idx[i]]
          end
****0     return setmeta(res,tbl,'List')
      end

      --- apply a function to all values of a table.
      -- This returns a table of the results.
      -- Any extra arguments are passed to the function.
      -- @within MappingAndFiltering
      -- @func fun A function that takes at least one argument
      -- @tab t A table
      -- @param ... optional arguments
      -- @usage map(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900,fred=4}
****0 function tablex.map(fun,t,...)
****0     assert_arg_iterable(1,t)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     for k,v in pairs(t) do
****0         res[k] = fun(v,...)
          end
****0     return setmeta(res,t)
      end

      --- apply a function to all values of a list.
      -- This returns a table of the results.
      -- Any extra arguments are passed to the function.
      -- @within MappingAndFiltering
      -- @func fun A function that takes at least one argument
      -- @array t a table (applies to array part)
      -- @param ... optional arguments
      -- @return a list-like table
      -- @usage imap(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900}
****0 function tablex.imap(fun,t,...)
****0     assert_arg_indexable(1,t)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     for i = 1,#t do
****0         res[i] = fun(t[i],...) or false
          end
****0     return setmeta(res,t,'List')
      end

      --- apply a named method to values from a table.
      -- @within MappingAndFiltering
      -- @string name the method name
      -- @array t a list-like table
      -- @param ... any extra arguments to the method
      -- @return a `List` with the results of the method (1st result only)
      -- @usage
      -- local Car = {}
      -- Car.__index = Car
      -- function Car.new(car)
      --   return setmetatable(car or {}, Car)
      -- end
      -- Car.speed = 0
      -- function Car:faster(increase)
      --   self.speed = self.speed + increase
      --   return self.speed
      -- end
      --
      -- local ferrari = Car.new{ name = "Ferrari" }
      -- local lamborghini = Car.new{ name = "Lamborghini", speed = 50 }
      -- local cars = { ferrari, lamborghini }
      --
      -- assert(ferrari.speed == 0)
      -- assert(lamborghini.speed == 50)
      -- tablex.map_named_method("faster", cars, 10)
      -- assert(ferrari.speed == 10)
      -- assert(lamborghini.speed == 60)
****0 function tablex.map_named_method (name,t,...)
****0     utils.assert_string(1,name)
****0     assert_arg_indexable(2,t)
****0     local res = {}
****0     for i = 1,#t do
****0         local val = t[i]
****0         local fun = val[name]
****0         res[i] = fun(val,...)
          end
****0     return setmeta(res,t,'List')
      end

      --- apply a function to all values of a table, in-place.
      -- Any extra arguments are passed to the function.
      -- @func fun A function that takes at least one argument
      -- @tab t a table
      -- @param ... extra arguments passed to `fun`
      -- @see tablex.foreach
****0 function tablex.transform (fun,t,...)
****0     assert_arg_iterable(1,t)
****0     fun = function_arg(1,fun)
****0     for k,v in pairs(t) do
****0         t[k] = fun(v,...)
          end
      end

      --- generate a table of all numbers in a range.
      -- This is consistent with a numerical for loop.
      -- @int start  number
      -- @int finish number
      -- @int[opt=1] step  make this negative for start < finish
****0 function tablex.range (start,finish,step)
          local res
****0     step = step or 1
****0     if start == finish then
****0         res = {start}
****0     elseif (start > finish and step > 0) or (finish > start and step < 0) then
****0         res = {}
          else
****0         local k = 1
****0         res = {}
****0         for i=start,finish,step do res[k]=i; k=k+1 end
          end
****0     return makelist(res)
      end

      --- apply a function to values from two tables.
      -- @within MappingAndFiltering
      -- @func fun a function of at least two arguments
      -- @tab t1 a table
      -- @tab t2 a table
      -- @param ... extra arguments
      -- @return a table
      -- @usage map2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23,m=44}
****0 function tablex.map2 (fun,t1,t2,...)
****0     assert_arg_iterable(1,t1)
****0     assert_arg_iterable(2,t2)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     for k,v in pairs(t1) do
****0         res[k] = fun(v,t2[k],...)
          end
****0     return setmeta(res,t1,'List')
      end

      --- apply a function to values from two arrays.
      -- The result will be the length of the shortest array.
      -- @within MappingAndFiltering
      -- @func fun a function of at least two arguments
      -- @array t1 a list-like table
      -- @array t2 a list-like table
      -- @param ... extra arguments
      -- @usage imap2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23}
****0 function tablex.imap2 (fun,t1,t2,...)
****0     assert_arg_indexable(2,t1)
****0     assert_arg_indexable(3,t2)
****0     fun = function_arg(1,fun)
****0     local res,n = {},math.min(#t1,#t2)
****0     for i = 1,n do
****0         res[i] = fun(t1[i],t2[i],...)
          end
****0     return res
      end

      --- 'reduce' a list using a binary function.
      -- @func fun a function of two arguments
      -- @array t a list-like table
      -- @array memo optional initial memo value. Defaults to first value in table.
      -- @return the result of the function
      -- @usage reduce('+',{1,2,3,4}) == 10
****0 function tablex.reduce (fun,t,memo)
****0     assert_arg_indexable(2,t)
****0     fun = function_arg(1,fun)
****0     local n = #t
****0     if n == 0 then
****0         return memo
          end
****0     local res = memo and fun(memo, t[1]) or t[1]
****0     for i = 2,n do
****0         res = fun(res,t[i])
          end
****0     return res
      end

      --- apply a function to all elements of a table.
      -- The arguments to the function will be the value,
      -- the key and _finally_ any extra arguments passed to this function.
      -- Note that the Lua 5.0 function table.foreach passed the _key_ first.
      -- @within Iterating
      -- @tab t a table
      -- @func fun a function on the elements; `function(value, key, ...)`
      -- @param ... extra arguments passed to `fun`
      -- @see tablex.transform
****0 function tablex.foreach(t,fun,...)
****0     assert_arg_iterable(1,t)
****0     fun = function_arg(2,fun)
****0     for k,v in pairs(t) do
****0         fun(v,k,...)
          end
      end

      --- apply a function to all elements of a list-like table in order.
      -- The arguments to the function will be the value,
      -- the index and _finally_ any extra arguments passed to this function
      -- @within Iterating
      -- @array t a table
      -- @func fun a function with at least one argument
      -- @param ... optional arguments
****0 function tablex.foreachi(t,fun,...)
****0     assert_arg_indexable(1,t)
****0     fun = function_arg(2,fun)
****0     for i = 1,#t do
****0         fun(t[i],i,...)
          end
      end

      --- Apply a function to a number of tables.
      -- A more general version of map
      -- The result is a table containing the result of applying that function to the
      -- ith value of each table. Length of output list is the minimum length of all the lists
      -- @within MappingAndFiltering
      -- @func fun a function of n arguments
      -- @tab ... n tables
      -- @usage mapn(function(x,y,z) return x+y+z end, {1,2,3},{10,20,30},{100,200,300}) is {111,222,333}
      -- @usage mapn(math.max, {1,20,300},{10,2,3},{100,200,100}) is    {100,200,300}
      -- @param fun A function that takes as many arguments as there are tables
****0 function tablex.mapn(fun,...)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     local lists = {...}
****0     local minn = 1e40
****0     for i = 1,#lists do
****0         minn = min(minn,#(lists[i]))
          end
****0     for i = 1,minn do
****0         local args,k = {},1
****0         for j = 1,#lists do
****0             args[k] = lists[j][i]
****0             k = k + 1
              end
****0         res[#res+1] = fun(unpack(args))
          end
****0     return res
      end

      --- call the function with the key and value pairs from a table.
      -- The function can return a value and a key (note the order!). If both
      -- are not nil, then this pair is inserted into the result: if the key already exists, we convert the value for that
      -- key into a table and append into it. If only value is not nil, then it is appended to the result.
      -- @within MappingAndFiltering
      -- @func fun A function which will be passed each key and value as arguments, plus any extra arguments to pairmap.
      -- @tab t A table
      -- @param ... optional arguments
      -- @usage pairmap(function(k,v) return v end,{fred=10,bonzo=20}) is {10,20} _or_ {20,10}
      -- @usage pairmap(function(k,v) return {k,v},k end,{one=1,two=2}) is {one={'one',1},two={'two',2}}
****0 function tablex.pairmap(fun,t,...)
****0     assert_arg_iterable(1,t)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     for k,v in pairs(t) do
****0         local rv,rk = fun(k,v,...)
****0         if rk then
****0             if res[rk] then
****0                 if type(res[rk]) == 'table' then
****0                     table.insert(res[rk],rv)
                      else
****0                     res[rk] = {res[rk], rv}
                      end
                  else
****0                 res[rk] = rv
                  end
              else
****0             res[#res+1] = rv
              end
          end
****0     return res
      end

****0 local function keys_op(i,v) return i end

      --- return all the keys of a table in arbitrary order.
      -- @within Extraction
      --  @tab t A table
****0 function tablex.keys(t)
****0     assert_arg_iterable(1,t)
****0     return makelist(tablex.pairmap(keys_op,t))
      end

****0 local function values_op(i,v) return v end

      --- return all the values of the table in arbitrary order
      -- @within Extraction
      --  @tab t A table
****0 function tablex.values(t)
****0     assert_arg_iterable(1,t)
****0     return makelist(tablex.pairmap(values_op,t))
      end

****0 local function index_map_op (i,v) return i,v end

      --- create an index map from a list-like table. The original values become keys,
      -- and the associated values are the indices into the original list.
      -- @array t a list-like table
      -- @return a map-like table
****0 function tablex.index_map (t)
****0     assert_arg_indexable(1,t)
****0     return makemap(tablex.pairmap(index_map_op,t))
      end

****0 local function set_op(i,v) return true,v end

      --- create a set from a list-like table. A set is a table where the original values
      -- become keys, and the associated values are all true.
      -- @array t a list-like table
      -- @return a set (a map-like table)
****0 function tablex.makeset (t)
****0     assert_arg_indexable(1,t)
****0     return setmetatable(tablex.pairmap(set_op,t),require('pl.Set'))
      end

      --- combine two tables, either as union or intersection. Corresponds to
      -- set operations for sets () but more general. Not particularly
      -- useful for list-like tables.
      -- @within Merging
      -- @tab t1 a table
      -- @tab t2 a table
      -- @bool dup true for a union, false for an intersection.
      -- @usage merge({alice=23,fred=34},{bob=25,fred=34}) is {fred=34}
      -- @usage merge({alice=23,fred=34},{bob=25,fred=34},true) is {bob=25,fred=34,alice=23}
      -- @see tablex.index_map
****0 function tablex.merge (t1,t2,dup)
****0     assert_arg_iterable(1,t1)
****0     assert_arg_iterable(2,t2)
****0     local res = {}
****0     for k,v in pairs(t1) do
****0         if dup or t2[k] then res[k] = v end
          end
****0     if dup then
****0       for k,v in pairs(t2) do
****0         res[k] = v
            end
          end
****0     return setmeta(res,t1,'Map')
      end

      --- the union of two map-like tables.
      -- If there are duplicate keys, the second table wins.
      -- @tab t1 a table
      -- @tab t2 a table
      -- @treturn tab
      -- @see tablex.merge
****0 function tablex.union(t1, t2)
****0     return tablex.merge(t1, t2, true)
      end

      --- the intersection of two map-like tables.
      -- @tab t1 a table
      -- @tab t2 a table
      -- @treturn tab
      -- @see tablex.merge
****0 function tablex.intersection(t1, t2)
****0     return tablex.merge(t1, t2, false)
      end

      --- a new table which is the difference of two tables.
      -- With sets (where the values are all true) this is set difference and
      -- symmetric difference depending on the third parameter.
      -- @within Merging
      -- @tab s1 a map-like table or set
      -- @tab s2 a map-like table or set
      -- @bool symm symmetric difference (default false)
      -- @return a map-like table or set
****0 function tablex.difference (s1,s2,symm)
****0     assert_arg_iterable(1,s1)
****0     assert_arg_iterable(2,s2)
****0     local res = {}
****0     for k,v in pairs(s1) do
****0         if s2[k] == nil then res[k] = v end
          end
****0     if symm then
****0         for k,v in pairs(s2) do
****0             if s1[k] == nil then res[k] = v end
              end
          end
****0     return setmeta(res,s1,'Map')
      end

      --- A table where the key/values are the values and value counts of the table.
      -- @array t a list-like table
      -- @func cmp a function that defines equality (otherwise uses ==)
      -- @return a map-like table
      -- @see seq.count_map
****0 function tablex.count_map (t,cmp)
****0     assert_arg_indexable(1,t)
****0     local res,mask = {},{}
****0     cmp = function_arg(2,cmp or '==')
****0     local n = #t
****0     for i = 1,#t do
****0         local v = t[i]
****0         if not mask[v] then
****0             mask[v] = true
                  -- check this value against all other values
****0             res[v] = 1  -- there's at least one instance
****0             for j = i+1,n do
****0                 local w = t[j]
****0                 local ok = cmp(v,w)
****0                 if ok then
****0                     res[v] = res[v] + 1
****0                     mask[w] = true
                      end
                  end
              end
          end
****0     return makemap(res)
      end

      --- filter an array's values using a predicate function
      -- @within MappingAndFiltering
      -- @array t a list-like table
      -- @func pred a boolean function
      -- @param arg optional argument to be passed as second argument of the predicate
****0 function tablex.filter (t,pred,arg)
    2     assert_arg_indexable(1,t)
    2     pred = function_arg(2,pred)
    2     local res,k = {},1
    7     for i = 1,#t do
    5         local v = t[i]
    5         if pred(v,arg) then
    4             res[k] = v
    4             k = k + 1
              end
          end
    2     return setmeta(res,t,'List')
      end

      --- return a table where each element is a table of the ith values of an arbitrary
      -- number of tables. It is equivalent to a matrix transpose.
      -- @within Merging
      -- @usage zip({10,20,30},{100,200,300}) is {{10,100},{20,200},{30,300}}
      -- @array ... arrays to be zipped
****0 function tablex.zip(...)
****0     return tablex.mapn(function(...) return {...} end,...)
      end

      local _copy
****0 function _copy (dest,src,idest,isrc,nsrc,clean_tail)
****0     idest = idest or 1
****0     isrc = isrc or 1
          local iend
****0     if not nsrc then
****0         nsrc = #src
****0         iend = #src
          else
****0         iend = isrc + min(nsrc-1,#src-isrc)
          end
****0     if dest == src then -- special case
****0         if idest > isrc and iend >= idest then -- overlapping ranges
****0             src = tablex.sub(src,isrc,nsrc)
****0             isrc = 1; iend = #src
              end
          end
****0     for i = isrc,iend do
****0         dest[idest] = src[i]
****0         idest = idest + 1
          end
****0     if clean_tail then
****0         tablex.clear(dest,idest)
          end
****0     return dest
      end

      --- copy an array into another one, clearing `dest` after `idest+nsrc`, if necessary.
      -- @within Copying
      -- @array dest a list-like table
      -- @array src a list-like table
      -- @int[opt=1] idest where to start copying values into destination
      -- @int[opt=1] isrc where to start copying values from source
      -- @int[opt=#src] nsrc number of elements to copy from source
****0 function tablex.icopy (dest,src,idest,isrc,nsrc)
****0     assert_arg_indexable(1,dest)
****0     assert_arg_indexable(2,src)
****0     return _copy(dest,src,idest,isrc,nsrc,true)
      end

      --- copy an array into another one.
      -- @within Copying
      -- @array dest a list-like table
      -- @array src a list-like table
      -- @int[opt=1] idest where to start copying values into destination
      -- @int[opt=1] isrc where to start copying values from source
      -- @int[opt=#src] nsrc number of elements to copy from source
****0 function tablex.move (dest,src,idest,isrc,nsrc)
****0     assert_arg_indexable(1,dest)
****0     assert_arg_indexable(2,src)
****0     return _copy(dest,src,idest,isrc,nsrc,false)
      end

****0 function tablex._normalize_slice(self,first,last)
****0   local sz = #self
****0   if not first then first=1 end
****0   if first<0 then first=sz+first+1 end
        -- make the range _inclusive_!
****0   if not last then last=sz end
****0   if last < 0 then last=sz+1+last end
****0   return first,last
      end

      --- Extract a range from a table, like  'string.sub'.
      -- If first or last are negative then they are relative to the end of the list
      -- eg. sub(t,-2) gives last 2 entries in a list, and
      -- sub(t,-4,-2) gives from -4th to -2nd
      -- @within Extraction
      -- @array t a list-like table
      -- @int first An index
      -- @int last An index
      -- @return a new List
****0 function tablex.sub(t,first,last)
****0     assert_arg_indexable(1,t)
****0     first,last = tablex._normalize_slice(t,first,last)
****0     local res={}
****0     for i=first,last do append(res,t[i]) end
****0     return setmeta(res,t,'List')
      end

      --- set an array range to a value. If it's a function we use the result
      -- of applying it to the indices.
      -- @array t a list-like table
      -- @param val a value
      -- @int[opt=1] i1 start range
      -- @int[opt=#t] i2 end range
****0 function tablex.set (t,val,i1,i2)
****0     assert_arg_indexable(1,t)
****0     i1,i2 = i1 or 1,i2 or #t
****0     if types.is_callable(val) then
****0         for i = i1,i2 do
****0             t[i] = val(i)
              end
          else
****0         for i = i1,i2 do
****0             t[i] = val
              end
          end
      end

      --- create a new array of specified size with initial value.
      -- @int n size
      -- @param val initial value (can be `nil`, but don't expect `#` to work!)
      -- @return the table
****0 function tablex.new (n,val)
****0     local res = {}
****0     tablex.set(res,val,1,n)
****0     return res
      end

      --- clear out the contents of a table.
      -- @array t a list
      -- @param istart optional start position
****0 function tablex.clear(t,istart)
****0     istart = istart or 1
****0     for i = istart,#t do remove(t) end
      end

      --- insert values into a table.
      -- similar to `table.insert` but inserts values from given table `values`,
      -- not the object itself, into table `t` at position `pos`.
      -- @within Copying
      -- @array t the list
      -- @int[opt] position (default is at end)
      -- @array values
****0 function tablex.insertvalues(t, ...)
    1     assert_arg(1,t,'table')
          local pos, values
    1     if select('#', ...) == 1 then
    1         pos,values = #t+1, ...
          else
****0         pos,values = ...
          end
    1     if #values > 0 then
    1         for i=#t,pos,-1 do
****0             t[i+#values] = t[i]
              end
    1         local offset = 1 - pos
    3         for i=pos,pos+#values-1 do
    2             t[i] = values[i + offset]
              end
          end
    1     return t
      end

      --- remove a range of values from a table.
      -- End of range may be negative.
      -- @array t a list-like table
      -- @int i1 start index
      -- @int i2 end index
      -- @return the table
****0 function tablex.removevalues (t,i1,i2)
****0     assert_arg(1,t,'table')
****0     i1,i2 = tablex._normalize_slice(t,i1,i2)
****0     for i = i1,i2 do
****0         remove(t,i1)
          end
****0     return t
      end

      local _find
      _find = function (t,value,tables)
****0     for k,v in pairs(t) do
****0         if v == value then return k end
          end
****0     for k,v in pairs(t) do
****0         if not tables[v] and type(v) == 'table' then
****0             tables[v] = true
****0             local res = _find(v,value,tables)
****0             if res then
****0                 res = tostring(res)
****0                 if type(k) ~= 'string' then
****0                     return '['..k..']'..res
                      else
****0                     return k..'.'..res
                      end
                  end
              end
          end
      end

      --- find a value in a table by recursive search.
      -- @within Finding
      -- @tab t the table
      -- @param value the value
      -- @array[opt] exclude any tables to avoid searching
      -- @return a fieldspec, e.g. 'a.b' or 'math.sin'
      -- @usage search(_G,math.sin,{package.path}) == 'math.sin'
****0 function tablex.search (t,value,exclude)
****0     assert_arg_iterable(1,t)
****0     local tables = {[t]=true}
****0     if exclude then
****0         for _,v in pairs(exclude) do tables[v] = true end
          end
****0     return _find(t,value,tables)
      end

      --- return an iterator to a table sorted by its keys
      -- @within Iterating
      -- @tab t the table
      -- @func f an optional comparison function (f(x,y) is true if x < y)
      -- @usage for k,v in tablex.sort(t) do print(k,v) end
      -- @return an iterator to traverse elements sorted by the keys
****0 function tablex.sort(t,f)
****0     local keys = {}
****0     for k in pairs(t) do keys[#keys + 1] = k end
****0     tsort(keys,f)
****0     local i = 0
          return function()
****0         i = i + 1
****0         return keys[i], t[keys[i]]
          end
      end

      --- return an iterator to a table sorted by its values
      -- @within Iterating
      -- @tab t the table
      -- @func f an optional comparison function (f(x,y) is true if x < y)
      -- @usage for k,v in tablex.sortv(t) do print(k,v) end
      -- @return an iterator to traverse elements sorted by the values
****0 function tablex.sortv(t,f)
****0     f = function_arg(2, f or '<')
****0     local keys = {}
****0     for k in pairs(t) do keys[#keys + 1] = k end
****0     tsort(keys,function(x, y) return f(t[x], t[y]) end)
****0     local i = 0
          return function()
****0         i = i + 1
****0         return keys[i], t[keys[i]]
          end
      end

      --- modifies a table to be read only.
      -- This only offers weak protection. Tables can still be modified with
      -- `table.insert` and `rawset`.
      --
      -- *NOTE*: for Lua 5.1 length, pairs and ipairs will not work, since the
      -- equivalent metamethods are only available in Lua 5.2 and newer.
      -- @tab t the table
      -- @return the table read only (a proxy).
****0 function tablex.readonly(t)
****0     local mt = {
              __index=t,
              __newindex=function(t, k, v) error("Attempt to modify read-only table", 2) end,
              __pairs=function() return pairs(t) end,
              __ipairs=function() return ipairs(t) end,
              __len=function() return #t end,
****0         __metatable=false
          }
****0     return setmetatable({}, mt)
      end

****0 return tablex

==============================================================================
/usr/local/share/lua/5.3/pl/types.lua
==============================================================================
      ---- Dealing with Detailed Type Information

      -- Dependencies `pl.utils`
      -- @module pl.types

****0 local utils = require 'pl.utils'
****0 local math_ceil = math.ceil
****0 local assert_arg = utils.assert_arg
****0 local types = {}

      --- is the object either a function or a callable object?.
      -- @param obj Object to check.
****0 function types.is_callable (obj)
****0     return type(obj) == 'function' or getmetatable(obj) and getmetatable(obj).__call and true
      end

      --- is the object of the specified type?.
      -- If the type is a string, then use type, otherwise compare with metatable.
      --
      -- NOTE: this function is imported from `utils.is_type`.
      -- @param obj An object to check
      -- @param tp The expected type
      -- @function is_type
      -- @see utils.is_type
****0 types.is_type = utils.is_type

****0 local fileMT = getmetatable(io.stdout)

      --- a string representation of a type.
      -- For tables and userdata with metatables, we assume that the metatable has a `_name`
      -- field. If the field is not present it will return 'unknown table' or
      -- 'unknown userdata'.
      -- Lua file objects return the type 'file'.
      -- @param obj an object
      -- @return a string like 'number', 'table', 'file' or 'List'
****0 function types.type (obj)
****0     local t = type(obj)
****0     if t == 'table' or t == 'userdata' then
****0         local mt = getmetatable(obj)
****0         if mt == fileMT then
****0             return 'file'
****0         elseif mt == nil then
****0             return t
              else
                  -- TODO: the "unknown" is weird, it should just return the type
****0             return mt._name or "unknown "..t
              end
          else
****0         return t
          end
      end

      --- is this number an integer?
      -- @param x a number
      -- @raise error if x is not a number
      -- @return boolean
****0 function types.is_integer (x)
****0     return math_ceil(x)==x
      end

      --- Check if the object is "empty".
      -- An object is considered empty if it is:
      --
      -- - `nil`
      -- - a table with out any items (key-value pairs or indexes)
      -- - a string with no content ("")
      -- - not a nil/table/string
      -- @param o The object to check if it is empty.
      -- @param ignore_spaces If the object is a string and this is true the string is
      -- considered empty if it only contains spaces.
      -- @return `true` if the object is empty, otherwise a falsy value.
****0 function types.is_empty(o, ignore_spaces)
****0     if o == nil then
****0         return true
****0     elseif type(o) == "table" then
****0         return next(o) == nil
****0     elseif type(o) == "string" then
****0         return o == "" or (not not ignore_spaces and (not not o:find("^%s+$")))
          else
****0         return true
          end
      end

      local function check_meta (val)
    5     if type(val) == 'table' then return true end
****0     return getmetatable(val)
      end

      --- is an object 'array-like'?
      -- An object is array like if:
      --
      -- - it is a table, or
      -- - it has a metatable with `__len` and `__index` methods
      --
      -- NOTE: since `__len` is 5.2+, on 5.1 is usually returns `false` for userdata
      -- @param val any value.
      -- @return `true` if the object is array-like, otherwise a falsy value.
****0 function types.is_indexable (val)
    2     local mt = check_meta(val)
    2     if mt == true then return true end
****0     return mt and mt.__len and mt.__index and true
      end

      --- can an object be iterated over with `pairs`?
      -- An object is iterable if:
      --
      -- - it is a table, or
      -- - it has a metatable with a `__pairs` meta method
      --
      -- NOTE: since `__pairs` is 5.2+, on 5.1 is usually returns `false` for userdata
      -- @param val any value.
      -- @return `true` if the object is iterable, otherwise a falsy value.
****0 function types.is_iterable (val)
    3     local mt = check_meta(val)
    3     if mt == true then return true end
****0     return mt and mt.__pairs and true
      end

      --- can an object accept new key/pair values?
      -- An object is iterable if:
      --
      -- - it is a table, or
      -- - it has a metatable with a `__newindex` meta method
      --
      -- @param val any value.
      -- @return `true` if the object is writeable, otherwise a falsy value.
****0 function types.is_writeable (val)
****0     local mt = check_meta(val)
****0     if mt == true then return true end
****0     return mt and mt.__newindex and true
      end

      -- Strings that should evaluate to true.   -- TODO: add on/off ???
****0 local trues = { yes=true, y=true, ["true"]=true, t=true, ["1"]=true }
      -- Conditions types should evaluate to true.
****0 local true_types = {
          boolean=function(o, true_strs, check_objs) return o end,
          string=function(o, true_strs, check_objs)
****0         o = o:lower()
****0         if trues[o] then
****0             return true
              end
              -- Check alternative user provided strings.
****0         for _,v in ipairs(true_strs or {}) do
****0             if type(v) == "string" and o == v:lower() then
****0                 return true
                  end
              end
****0         return false
          end,
          number=function(o, true_strs, check_objs) return o ~= 0 end,
****0     table=function(o, true_strs, check_objs) if check_objs and next(o) ~= nil then return true end return false end
      }
      --- Convert to a boolean value.
      -- True values are:
      --
      -- * boolean: true.
      -- * string: 'yes', 'y', 'true', 't', '1' or additional strings specified by `true_strs`.
      -- * number: Any non-zero value.
      -- * table: Is not empty and `check_objs` is true.
      -- * everything else: Is not `nil` and `check_objs` is true.
      --
      -- @param o The object to evaluate.
      -- @param[opt] true_strs optional Additional strings that when matched should evaluate to true. Comparison is case insensitive.
      -- This should be a List of strings. E.g. "ja" to support German.
      -- @param[opt] check_objs True if objects should be evaluated.
      -- @return true if the input evaluates to true, otherwise false.
****0 function types.to_bool(o, true_strs, check_objs)
          local true_func
****0     if true_strs then
****0         assert_arg(2, true_strs, "table")
          end
****0     true_func = true_types[type(o)]
****0     if true_func then
****0         return true_func(o, true_strs, check_objs)
****0     elseif check_objs and o ~= nil then
****0         return true
          end
****0     return false
      end


****0 return types

==============================================================================
/usr/local/share/lua/5.3/pl/utils.lua
==============================================================================
      --- Generally useful routines.
      -- See  @{01-introduction.md.Generally_useful_functions|the Guide}.
      --
      -- Dependencies: `pl.compat`, all exported fields and functions from
      -- `pl.compat` are also available in this module.
      --
      -- @module pl.utils
****0 local format = string.format
****0 local compat = require 'pl.compat'
****0 local stdout = io.stdout
****0 local append = table.insert
****0 local _unpack = table.unpack  -- always injected by 'compat'

****0 local is_windows = compat.is_windows
****0 local err_mode = 'default'
      local raise
      local operators
****0 local _function_factories = {}


****0 local utils = { _VERSION = "1.9.2" }
****0 for k, v in pairs(compat) do utils[k] = v  end

      --- Some standard patterns
      -- @table patterns
****0 utils.patterns = {
          FLOAT = '[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*', -- floating point number
          INTEGER = '[+%-%d]%d*',                     -- integer number
          IDEN = '[%a_][%w_]*',                       -- identifier
          FILE = '[%a%.\\][:%][%w%._%-\\]*',          -- file
      }


      --- Standard meta-tables as used by other Penlight modules
      -- @table stdmt
      -- @field List the List metatable
      -- @field Map the Map metatable
      -- @field Set the Set metatable
      -- @field MultiMap the MultiMap metatable
****0 utils.stdmt = {
          List = {_name='List'},
          Map = {_name='Map'},
          Set = {_name='Set'},
          MultiMap = {_name='MultiMap'},
      }


      --- pack an argument list into a table.
      -- @param ... any arguments
      -- @return a table with field `n` set to the length
      -- @function utils.pack
      -- @see compat.pack
****0 utils.pack = table.pack  -- added here to be symmetrical with unpack

      --- unpack a table and return its contents.
      --
      -- NOTE: this implementation differs from the Lua implementation in the way
      -- that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.
      -- @param t table to unpack
      -- @param[opt] i index from which to start unpacking, defaults to 1
      -- @param[opt] t index of the last element to unpack, defaults to `t.n` or `#t`
      -- @return multiple return values from the table
      -- @function utils.unpack
      -- @see compat.unpack
      -- @usage
      -- local t = table.pack(nil, nil, nil, 4)
      -- local a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil
      --
      -- local a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4
****0 function utils.unpack(t, i, j)
****0     return _unpack(t, i or 1, j or t.n or #t)
      end

      --- print an arbitrary number of arguments using a format.
      -- Output will be sent to `stdout`.
      -- @param fmt The format (see `string.format`)
      -- @param ... Extra arguments for format
****0 function utils.printf(fmt, ...)
****0     utils.assert_string(1, fmt)
****0     utils.fprintf(stdout, fmt, ...)
      end

      --- write an arbitrary number of arguments to a file using a format.
      -- @param f File handle to write to.
      -- @param fmt The format (see `string.format`).
      -- @param ... Extra arguments for format
****0 function utils.fprintf(f,fmt,...)
****0     utils.assert_string(2,fmt)
****0     f:write(format(fmt,...))
      end

      do
          local function import_symbol(T,k,v,libname)
****0         local key = rawget(T,k)
              -- warn about collisions!
****0         if key and k ~= '_M' and k ~= '_NAME' and k ~= '_PACKAGE' and k ~= '_VERSION' then
****0             utils.fprintf(io.stderr,"warning: '%s.%s' will not override existing symbol\n",libname,k)
****0             return
              end
****0         rawset(T,k,v)
          end

          local function lookup_lib(T,t)
****0         for k,v in pairs(T) do
****0             if v == t then return k end
              end
****0         return '?'
          end

****0     local already_imported = {}

          --- take a table and 'inject' it into the local namespace.
          -- @param t The table (table), or module name (string), defaults to this `utils` module table
          -- @param T An optional destination table (defaults to callers environment)
****0     function utils.import(t,T)
****0         T = T or _G
****0         t = t or utils
****0         if type(t) == 'string' then
****0             t = require (t)
              end
****0         local libname = lookup_lib(T,t)
****0         if already_imported[t] then return end
****0         already_imported[t] = libname
****0         for k,v in pairs(t) do
****0             import_symbol(T,k,v,libname)
              end
          end
      end

      --- return either of two values, depending on a condition.
      -- @param cond A condition
      -- @param value1 Value returned if cond is truthy
      -- @param value2 Value returned if cond is falsy
****0 function utils.choose(cond, value1, value2)
****0     return cond and value1 or value2
      end

      --- convert an array of values to strings.
      -- @param t a list-like table
      -- @param[opt] temp (table) buffer to use, otherwise allocate
      -- @param[opt] tostr custom tostring function, called with (value,index). Defaults to `tostring`.
      -- @return the converted buffer
****0 function utils.array_tostring (t,temp,tostr)
****0     temp, tostr = temp or {}, tostr or tostring
****0     for i = 1,#t do
****0         temp[i] = tostr(t[i],i)
          end
****0     return temp
      end



      --- is the object of the specified type?
      -- If the type is a string, then use type, otherwise compare with metatable
      -- @param obj An object to check
      -- @param tp String of what type it should be
      -- @return boolean
      -- @usage utils.is_type("hello world", "string")   --> true
      -- -- or check metatable
      -- local my_mt = {}
      -- local my_obj = setmetatable(my_obj, my_mt)
      -- utils.is_type(my_obj, my_mt)  --> true
****0 function utils.is_type (obj,tp)
****0     if type(tp) == 'string' then return type(obj) == tp end
****0     local mt = getmetatable(obj)
****0     return tp == mt
      end

      --- Error handling
      -- @section Error-handling

      --- assert that the given argument is in fact of the correct type.
      -- @param n argument index
      -- @param val the value
      -- @param tp the type
      -- @param verify an optional verification function
      -- @param msg an optional custom message
      -- @param lev optional stack position for trace, default 2
      -- @return the validated value
      -- @raise if `val` is not the correct type
      -- @usage
      -- local param1 = assert_arg(1,"hello",'table')  --> error: argument 1 expected a 'table', got a 'string'
      -- local param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')
      --      --> error: argument 4: '!@#$%^&*' not a directory
****0 function utils.assert_arg (n,val,tp,verify,msg,lev)
  128     if type(val) ~= tp then
****0         error(("argument %d expected a '%s', got a '%s'"):format(n,tp,type(val)),lev or 2)
          end
  128     if verify and not verify(val) then
****0         error(("argument %d: '%s' %s"):format(n,val,msg),lev or 2)
          end
  128     return val
      end

      --- process a function argument.
      -- This is used throughout Penlight and defines what is meant by a function:
      -- Something that is callable, or an operator string as defined by <code>pl.operator</code>,
      -- such as '>' or '#'. If a function factory has been registered for the type, it will
      -- be called to get the function.
      -- @param idx argument index
      -- @param f a function, operator string, or callable object
      -- @param msg optional error message
      -- @return a callable
      -- @raise if idx is not a number or if f is not callable
****0 function utils.function_arg (idx,f,msg)
    2     utils.assert_arg(1,idx,'number')
    2     local tp = type(f)
    2     if tp == 'function' then return f end  -- no worries!
          -- ok, a string can correspond to an operator (like '==')
****0     if tp == 'string' then
****0         if not operators then operators = require 'pl.operator'.optable end
****0         local fn = operators[f]
****0         if fn then return fn end
****0         local fn, err = utils.string_lambda(f)
****0         if not fn then error(err..': '..f) end
****0         return fn
****0     elseif tp == 'table' or tp == 'userdata' then
****0         local mt = getmetatable(f)
****0         if not mt then error('not a callable object',2) end
****0         local ff = _function_factories[mt]
****0         if not ff then
****0             if not mt.__call then error('not a callable object',2) end
****0             return f
              else
****0             return ff(f) -- we have a function factory for this type!
              end
          end
****0     if not msg then msg = " must be callable" end
****0     if idx > 0 then
****0         error("argument "..idx..": "..msg,2)
          else
****0         error(msg,2)
          end
      end


      --- assert the common case that the argument is a string.
      -- @param n argument index
      -- @param val a value that must be a string
      -- @return the validated value
      -- @raise val must be a string
      -- @usage
      -- local val = 42
      -- local param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'
****0 function utils.assert_string (n, val)
  124     return utils.assert_arg(n,val,'string',nil,nil,3)
      end

      --- control the error strategy used by Penlight.
      -- This is a global setting that controls how `utils.raise` behaves:
      --
      -- - 'default': return `nil + error` (this is the default)
      -- - 'error': throw a Lua error
      -- - 'quit': exit the program
      --
      -- @param mode either 'default', 'quit'  or 'error'
      -- @see utils.raise
****0 function utils.on_error (mode)
****0     mode = tostring(mode)
****0     if ({['default'] = 1, ['quit'] = 2, ['error'] = 3})[mode] then
****0       err_mode = mode
          else
            -- fail loudly
****0       local err = "Bad argument expected string; 'default', 'quit', or 'error'. Got '"..tostring(mode).."'"
****0       if err_mode == 'default' then
****0         error(err, 2)  -- even in 'default' mode fail loud in this case
            end
****0       raise(err)
          end
      end

      --- used by Penlight functions to return errors. Its global behaviour is controlled
      -- by `utils.on_error`.
      -- To use this function you MUST use it in conjunction with `return`, since it might
      -- return `nil + error`.
      -- @param err the error string.
      -- @see utils.on_error
      -- @usage
      -- if some_condition then
      --   return utils.raise("some condition was not met")  -- MUST use 'return'!
      -- end
****0 function utils.raise (err)
****0     if err_mode == 'default' then
****0         return nil, err
****0     elseif err_mode == 'quit' then
****0         return utils.quit(err)
          else
****0         error(err, 2)
          end
      end
****0 raise = utils.raise



      --- File handling
      -- @section files

      --- return the contents of a file as a string
      -- @param filename The file path
      -- @param is_bin open in binary mode
      -- @return file contents
****0 function utils.readfile(filename,is_bin)
****0     local mode = is_bin and 'b' or ''
****0     utils.assert_string(1,filename)
****0     local f,open_err = io.open(filename,'r'..mode)
****0     if not f then return raise (open_err) end
****0     local res,read_err = f:read('*a')
****0     f:close()
****0     if not res then
              -- Errors in io.open have "filename: " prefix,
              -- error in file:read don't, add it.
****0         return raise (filename..": "..read_err)
          end
****0     return res
      end

      --- write a string to a file
      -- @param filename The file path
      -- @param str The string
      -- @param is_bin open in binary mode
      -- @return true or nil
      -- @return error message
      -- @raise error if filename or str aren't strings
****0 function utils.writefile(filename,str,is_bin)
****0     local mode = is_bin and 'b' or ''
****0     utils.assert_string(1,filename)
****0     utils.assert_string(2,str)
****0     local f,err = io.open(filename,'w'..mode)
****0     if not f then return raise(err) end
****0     local ok, write_err = f:write(str)
****0     f:close()
****0     if not ok then
              -- Errors in io.open have "filename: " prefix,
              -- error in file:write don't, add it.
****0         return raise (filename..": "..write_err)
          end
****0     return true
      end

      --- return the contents of a file as a list of lines
      -- @param filename The file path
      -- @return file contents as a table
      -- @raise error if filename is not a string
****0 function utils.readlines(filename)
****0     utils.assert_string(1,filename)
****0     local f,err = io.open(filename,'r')
****0     if not f then return raise(err) end
****0     local res = {}
****0     for line in f:lines() do
****0         append(res,line)
          end
****0     f:close()
****0     return res
      end

      --- OS functions
      -- @section OS-functions

      --- execute a shell command and return the output.
      -- This function redirects the output to tempfiles and returns the content of those files.
      -- @param cmd a shell command
      -- @param bin boolean, if true, read output as binary file
      -- @return true if successful
      -- @return actual return code
      -- @return stdout output (string)
      -- @return errout output (string)
****0 function utils.executeex(cmd, bin)
****0     local outfile = os.tmpname()
****0     local errfile = os.tmpname()

****0     if is_windows and not outfile:find(':') then
****0         outfile = os.getenv('TEMP')..outfile
****0         errfile = os.getenv('TEMP')..errfile
          end
****0     cmd = cmd .. " > " .. utils.quote_arg(outfile) .. " 2> " .. utils.quote_arg(errfile)

****0     local success, retcode = utils.execute(cmd)
****0     local outcontent = utils.readfile(outfile, bin)
****0     local errcontent = utils.readfile(errfile, bin)
****0     os.remove(outfile)
****0     os.remove(errfile)
****0     return success, retcode, (outcontent or ""), (errcontent or "")
      end

      --- Quote and escape an argument of a command.
      -- Quotes a single (or list of) argument(s) of a command to be passed
      -- to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.
      -- @param argument (string or table/list) the argument to quote. If a list then
      -- all arguments in the list will be returned as a single string quoted.
      -- @return quoted and escaped argument.
      -- @usage
      -- local options = utils.quote_arg {
      --     "-lluacov",
      --     "-e",
      --     "utils = print(require('pl.utils')._VERSION",
      -- }
      -- -- returns: -lluacov -e 'utils = print(require('\''pl.utils'\'')._VERSION'
****0 function utils.quote_arg(argument)
****0     if type(argument) == "table" then
              -- encode an entire table
****0         local r = {}
****0         for i, arg in ipairs(argument) do
****0             r[i] = utils.quote_arg(arg)
              end

****0         return table.concat(r, " ")
          end
          -- only a single argument
****0     if is_windows then
****0         if argument == "" or argument:find('[ \f\t\v]') then
                  -- Need to quote the argument.
                  -- Quotes need to be escaped with backslashes;
                  -- additionally, backslashes before a quote, escaped or not,
                  -- need to be doubled.
                  -- See documentation for CommandLineToArgvW Windows function.
****0             argument = '"' .. argument:gsub([[(\*)"]], [[%1%1\"]]):gsub([[\+$]], "%0%0") .. '"'
              end

              -- os.execute() uses system() C function, which on Windows passes command
              -- to cmd.exe. Escape its special characters.
****0         return (argument:gsub('["^<>!|&%%]', "^%0"))
          else
****0         if argument == "" or argument:find('[^a-zA-Z0-9_@%+=:,./-]') then
                  -- To quote arguments on posix-like systems use single quotes.
                  -- To represent an embedded single quote close quoted string ('),
                  -- add escaped quote (\'), open quoted string again (').
****0             argument = "'" .. argument:gsub("'", [['\'']]) .. "'"
              end

****0         return argument
          end
      end

      --- error out of this program gracefully.
      -- @param[opt] code The exit code, defaults to -`1` if omitted
      -- @param msg The exit message will be sent to `stderr` (will be formatted with the extra parameters)
      -- @param ... extra arguments for message's format'
      -- @see utils.fprintf
      -- @usage utils.quit(-1, "Error '%s' happened", "42")
      -- -- is equivalent to
      -- utils.quit("Error '%s' happened", "42")  --> Error '42' happened
****0 function utils.quit(code, msg, ...)
****0     if type(code) == 'string' then
****0         utils.fprintf(io.stderr, code, msg, ...)
****0         io.stderr:write('\n')
****0         code = -1 -- TODO: this is odd, see the test. Which returns 255 as exit code
****0     elseif msg then
****0         utils.fprintf(io.stderr, msg, ...)
****0         io.stderr:write('\n')
          end
****0     os.exit(code, true)
      end


      --- String functions
      -- @section string-functions

      --- escape any Lua 'magic' characters in a string
      -- @param s The input string
****0 function utils.escape(s)
    3     utils.assert_string(1,s)
    3     return (s:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1'))
      end

      --- split a string into a list of strings separated by a delimiter.
      -- @param s The input string
      -- @param re A Lua string pattern; defaults to '%s+'
      -- @param plain don't use Lua patterns
      -- @param n optional maximum number of splits
      -- @return a list-like table
      -- @raise error if s is not a string
****0 function utils.split(s,re,plain,n)
****0     utils.assert_string(1,s)
****0     local find,sub,append = string.find, string.sub, table.insert
****0     local i1,ls = 1,{}
****0     if not re then re = '%s+' end
****0     if re == '' then return {s} end
          while true do
****0         local i2,i3 = find(s,re,i1,plain)
****0         if not i2 then
****0             local last = sub(s,i1)
****0             if last ~= '' then append(ls,last) end
****0             if #ls == 1 and ls[1] == '' then
****0                 return {}
                  else
****0                 return ls
                  end
              end
****0         append(ls,sub(s,i1,i2-1))
****0         if n and #ls == n then
****0             ls[#ls] = sub(s,i1)
****0             return ls
              end
****0         i1 = i3+1
          end
      end

      --- split a string into a number of return values.
      -- @param s the string
      -- @param re the delimiter, default space
      -- @return n values
      -- @usage first,next = splitv('jane:doe',':')
      -- @see split
****0 function utils.splitv (s,re)
****0     return _unpack(utils.split(s,re))
      end


      --- Functional
      -- @section functional


      --- 'memoize' a function (cache returned value for next call).
      -- This is useful if you have a function which is relatively expensive,
      -- but you don't know in advance what values will be required, so
      -- building a table upfront is wasteful/impossible.
      -- @param func a function of at least one argument
      -- @return a function with at least one argument, which is used as the key.
****0 function utils.memoize(func)
****0     local cache = {}
          return function(k)
****0         local res = cache[k]
****0         if res == nil then
****0             res = func(k)
****0             cache[k] = res
              end
****0         return res
          end
      end


      --- associate a function factory with a type.
      -- A function factory takes an object of the given type and
      -- returns a function for evaluating it
      -- @tab mt metatable
      -- @func fun a callable that returns a function
****0 function utils.add_function_factory (mt,fun)
****0     _function_factories[mt] = fun
      end

      local function _string_lambda(f)
****0     if f:find '^|' or f:find '_' then
****0         local args,body = f:match '|([^|]*)|(.+)'
****0         if f:find '_' then
****0             args = '_'
****0             body = f
              else
****0             if not args then return raise 'bad string lambda' end
              end
****0         local fstr = 'return function('..args..') return '..body..' end'
****0         local fn,err = utils.load(fstr)
****0         if not fn then return raise(err) end
****0         fn = fn()
****0         return fn
          else
****0         return raise 'not a string lambda'
          end
      end

      --- an anonymous function as a string. This string is either of the form
      -- '|args| expression' or is a function of one argument, '_'
      -- @param lf function as a string
      -- @return a function
      -- @function utils.string_lambda
      -- @usage
      -- string_lambda '|x|x+1' (2) == 3
      -- string_lambda '_+1' (2) == 3
****0 utils.string_lambda = utils.memoize(_string_lambda)


      --- bind the first argument of the function to a value.
      -- @param fn a function of at least two values (may be an operator string)
      -- @param p a value
      -- @return a function such that f(x) is fn(p,x)
      -- @raise same as @{function_arg}
      -- @see func.bind1
      -- @usage local function f(msg, name)
      --   print(msg .. " " .. name)
      -- end
      --
      -- local hello = utils.bind1(f, "Hello")
      --
      -- print(hello("world"))     --> "Hello world"
      -- print(hello("sunshine"))  --> "Hello sunshine"
****0 function utils.bind1 (fn,p)
****0     fn = utils.function_arg(1,fn)
****0     return function(...) return fn(p,...) end
      end

      --- bind the second argument of the function to a value.
      -- @param fn a function of at least two values (may be an operator string)
      -- @param p a value
      -- @return a function such that f(x) is fn(x,p)
      -- @raise same as @{function_arg}
      -- @usage local function f(a, b, c)
      --   print(a .. " " .. b .. " " .. c)
      -- end
      --
      -- local hello = utils.bind1(f, "world")
      --
      -- print(hello("Hello", "!"))  --> "Hello world !"
      -- print(hello("Bye", "?"))    --> "Bye world ?"
****0 function utils.bind2 (fn,p)
****0     fn = utils.function_arg(1,fn)
****0     return function(x,...) return fn(x,p,...) end
      end

****0 return utils



==============================================================================
/usr/local/share/lua/5.3/say/init.lua
==============================================================================
****0 local unpack = table.unpack or unpack

****0 local registry = { }
      local current_namespace
      local fallback_namespace

****0 local s = {

        _COPYRIGHT   = "Copyright (c) 2012 Olivine Labs, LLC.",
        _DESCRIPTION = "A simple string key/value store for i18n or any other case where you want namespaced strings.",
        _VERSION     = "Say 1.2",

        set_namespace = function(self, namespace)
    1     current_namespace = namespace
    1     if not registry[current_namespace] then
****0       registry[current_namespace] = {}
          end
        end,

        set_fallback = function(self, namespace)
****0     fallback_namespace = namespace
****0     if not registry[fallback_namespace] then
****0       registry[fallback_namespace] = {}
          end
        end,

        set = function(self, key, value)
   19     registry[current_namespace][key] = value
        end
      }

****0 local __meta = {
        __call = function(self, key, vars)
    8     vars = vars or {}

    8     local str = registry[current_namespace][key] or registry[fallback_namespace][key]

    8     if str == nil then
****0       return nil
          end
    8     str = tostring(str)
    8     local strings = {}

    8     for i,v in ipairs(vars) do
****0       table.insert(strings, tostring(v))
          end

    8     return #strings > 0 and str:format(unpack(strings)) or str
        end,

        __index = function(self, key)
****0     return registry[key]
        end
      }

****0 s:set_fallback('en')
****0 s:set_namespace('en')

****0 s._registry = registry

****0 return setmetatable(s, __meta)

==============================================================================
/usr/local/share/lua/5.3/term/colors.lua
==============================================================================
      -- Copyright (c) 2009 Rob Hoelz <rob@hoelzro.net>
      --
      -- Permission is hereby granted, free of charge, to any person obtaining a copy
      -- of this software and associated documentation files (the "Software"), to deal
      -- in the Software without restriction, including without limitation the rights
      -- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      -- copies of the Software, and to permit persons to whom the Software is
      -- furnished to do so, subject to the following conditions:
      --
      -- The above copyright notice and this permission notice shall be included in
      -- all copies or substantial portions of the Software.
      --
      -- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      -- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      -- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      -- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      -- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      -- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
      -- THE SOFTWARE.

****0 local pairs = pairs
****0 local tostring = tostring
****0 local setmetatable = setmetatable
****0 local schar = string.char

****0 local colors = {}

****0 local colormt = {}

****0 function colormt:__tostring()
   18     return self.value
      end

****0 function colormt:__concat(other)
   18     return tostring(self) .. tostring(other)
      end

****0 function colormt:__call(s)
    9     return self .. s .. colors.reset
      end

      local function makecolor(value)
****0     return setmetatable({ value = schar(27) .. '[' .. tostring(value) .. 'm' }, colormt)
      end

****0 local colorvalues = {
          -- attributes
          reset      = 0,
          clear      = 0,
          default    = 0,
          bright     = 1,
          dim        = 2,
          underscore = 4,
          blink      = 5,
          reverse    = 7,
          hidden     = 8,

          -- foreground
          black   = 30,
          red     = 31,
          green   = 32,
          yellow  = 33,
          blue    = 34,
          magenta = 35,
          cyan    = 36,
          white   = 37,

          -- background
          onblack   = 40,
          onred     = 41,
          ongreen   = 42,
          onyellow  = 43,
          onblue    = 44,
          onmagenta = 45,
          oncyan    = 46,
          onwhite   = 47,
      }

****0 for c, v in pairs(colorvalues) do
****0     colors[c] = makecolor(v)
      end

****0 return colors

==============================================================================
spec/buffer_spec.lua
==============================================================================
    1 local Buffer = require 'buffer'
    1 local char_maps = require "spec.char_maps"
    1 local buffer = require "buffer"

    2 describe('Buffer', function ()
    2     describe('utf-8', function ()
    2         it('should parse ascii characters', function ()
    1             local ascii = 'abcdefghijklmnopqrstuvwxyz'
    1             ascii = ascii .. string.upper(ascii)
    1             ascii = ascii .. '0123456789`!@#$%^&*()_+=-[]\\|}{;\'":/.,<>?'
    1             local b = Buffer.new(ascii)
   94             for ch in string.gmatch(ascii, '.') do
   93                 local i, len = b:next_utf8_int()
   93                 local target = string.byte(ch, 1, 1)
   93                 assert(i == target, string.format('expected byte for %s, found %s expected %s', ch, i, target))
   93                 b:advance(len)
                  end
              end)
    2         it('should parse 2 byte characters', function ()
    1             local char_map = char_maps.two_byte
    1             local s = ''
   95             for key, _ in pairs(char_map) do
   94                 s = s .. key
                  end
    1             local b = Buffer.new(s)
   95             for ch in string.gmatch(s, '..') do
   94                 local i, len = b:next_utf8_int()
   94                 local bytes = char_map[ch]
   94                 local expected = ((bytes[1] & 63) << 6) | (bytes[2] & 63)
   94                 assert(i, expected)
   94                 b:advance(len)
                  end
              end)
    2         it('should parse 3 byte characters', function ()
    1             local char_map = char_maps.three_byte
    1             local s = ''
  257             for key, _ in pairs(char_map) do
  256                 s = s .. key
                  end
    1             local b = Buffer.new(s)
  257             for ch in string.gmatch(s, '...') do
  256                 local i, len = b:next_utf8_int()
  256                 local bytes = char_map[ch]
  256                 local expected = ((bytes[1] & 63) << 12) | ((bytes[2] & 63) << 6) | (bytes[3] & 63)
  256                 assert(i, expected)
  256                 b:advance(len)
                  end
              end)
    2         it('should parse 4 byte characters', function ()
    1             local char_map = char_maps.four_byte
    1             local s = ''
  231             for key, _ in pairs(char_map) do
  230                 s = s .. key
                  end
    1             local b = Buffer.new(s)
  231             for ch in string.gmatch(s, '....') do
  230                 local i, len = b:next_utf8_int()
  230                 local bytes = char_map[ch]
  230                 local expected = ((bytes[1] & 63) << 18) | ((bytes[2] & 63) << 6) | ((bytes[3] & 63) << 6) | (bytes[4] & 63)
  230                 assert(i, expected)
  230                 b:advance(len)
                  end
              end)
          end)
    1     local text = 'asdfqwerzxcv'
    2     describe('advancing methods', function ()
    2         it('advance', function ()
    1             local b = Buffer.new(text)
    1             assert(b:current_byte() == string.byte('a'))
    1             assert(b:advance(4))
    1             assert(b:current_byte() == string.byte('q'))
    1             assert(b:advance(4))
    1             assert(b:current_byte() == string.byte('z'))
    1             assert(b:advance(3))
    1             assert(b:current_byte() == string.byte('v'))
    1             assert(not b:advance(1))
              end)
          end)
    2     describe('consume_str', function ()
    1         local b = Buffer.new(text)
    1         local asdf = assert(b:consume_str('asdf'))
    1         assert(asdf == 'asdf', string.format('expected asdf found "%s"', asdf))
    1         assert(b:current_byte() == string.byte('q'), string.char(b:current_byte()))
    1         assert(b:next_byte() == string.byte('w'), string.char(b:next_byte()))
          end)
    2     describe('consume_while', function ()
    1         local b = Buffer.new(text)
    2         local asdf = b:consume_while(function (ch)
    5             return ch ~= 'q'
              end)
    1         assert(asdf == 'asdf', asdf)
    1         local c = b:current_byte()
    1         local n = b:next_byte()
    1         assert(c == string.byte('q'), string.char(c))
    1         assert(n == string.byte('w'), string.char(n))
          end)
      end)

==============================================================================
spec/puller_spec.lua
==============================================================================
    1 local puller = require 'xml-puller'
    1 local event = require 'event'


    1 function _assert(test, ...)
   49     if not test then
****0         error(string.format(...), 2)
          end
      end

    2 describe('Puller', function ()
    2     describe('should parse decl', function ()
    2         it('with all values', function ()
    1             local p = puller.new('<?xml version="1.2" encoding="utf-8" standalone="no" ?>')
    1             local e = assert(p:next())
    1             _assert(e.ty == event.event_type.declaration, 'expected decl found %s', e.ty)
    1             _assert(e.version == '1.2', 'expected version 1.2 found %s', e.version)
    1             _assert(e.encoding == 'utf-8', 'expected utf-8 found %s', e.encoding)
    1             _assert(e.standalone == false, 'expected standalone to be false found %s', e.standalone)
              end)
          end)
    2     describe('should parse doctype', function()
    2         it('empty with all values', function ()
    1             local p = puller.new('<!DOCTYPE name PUBLIC "first_value" "second_value">')
    1             local e = assert(p:next())
    1             _assert(e.ty == event.event_type.doctype, 'expected empty doctype, found %s', e.ty)
    1             _assert(e.name == 'name', 'expected name of name found "%s"', e.name)
    1             _assert(e.external_id == 'PUBLIC', 'expected external_id of PUBLIC found "%s"', e.external_id)
    1             _assert(e.external_value[1] == 'first_value', 'expected external value first_value found "%s"', e.external_value[2])
    1             _assert(e.external_value[2] == 'second_value', 'expected external value second_value found "%s"', e.external_value[2])
              end)
    2         it('empty with SYSTEM', function ()
    1             local p = puller.new('<!DOCTYPE name SYSTEM "first_value">')
    1             local e = assert(p:next())
    1             _assert(e.ty == event.event_type.doctype, 'expected empty doctype, found %s', e.ty)
    1             _assert(e.name == 'name', 'expected name of name found "%s"', e.name)
    1             _assert(e.external_id == 'SYSTEM', 'expected external_id of SYSTEM found "%s"', e.external_id)
    1             _assert(e.external_value[1] == 'first_value', 'expected external value first_value found "%s"', e.external_value[2])
              end)
    2         it('not empty, one entity, not system or public', function ()
    2             local p = puller.new([[<!DOCTYPE svg [
                      <!ENTITY name "value">
    1             ]>]])
    1             local e1 = assert(p:next())
    1             _assert(e1.ty == event.event_type.doctype_start, 'expected %s found %s', event.event_type.doctype_start, e1.ty)
    1             _assert(e1.name == 'svg', 'expecte svg found %s', e1.name)
    1             _assert(e1.external_id == nil, 'expecte nil found %s', e1.external_id)
    1             _assert(#e1.external_value == 0, 'expecte 0 found %s', #e1.external_value)
    1             local e2 = assert(p:next())
    1             _assert(e2.ty == event.event_type.entity_declaration, 'expected %s found %s', event.event_type.entity_declaration, e2.ty)
    1             _assert(e2.name == 'name', 'Expected name found `%s`', e2.name)
    1             _assert(e2.external_value == 'value', 'expected value found `%s`', e2.external_value)

              end)
    2         it('not empty, entity, system and public', function ()
    2             local p = puller.new([[<!DOCTYPE svg [
                      <!ENTITY system SYSTEM "system_value">
                      <!ENTITY public PUBLIC "public_value1" "public_value2">
    1             ]>]])
    1             local e1 = assert(p:next())
    1             _assert(e1.ty == event.event_type.doctype_start, 'expected %s found %s', event.event_type.doctype_start, e1.ty)
    1             _assert(e1.name == 'svg', 'expecte svg found %s', e1.name)
    1             _assert(e1.external_id == nil, 'expecte nil found %s', e1.external_id)
    1             _assert(#e1.external_value == 0, 'expecte 0 found %s', #e1.external_value)
    1             local e2 = assert(p:next())
    1             _assert(e2.ty == event.event_type.entity_declaration, 'expected %s found %s', event.event_type.entity_declaration, e2.ty)
    1             _assert(e2.external_id == 'SYSTEM', 'Expected SYSTEM found `%s`', e2.external_id)
    1             _assert(e2.name == 'system', 'Expected system found `%s`', e2.name)
    1             _assert(e2.external_value[1] == 'system_value', 'expected system_value found `%s`', e2.external_value[1])
    1             local e3 = assert(p:next())
    1             _assert(e3.ty == event.event_type.entity_declaration, 'expected %s found %s', event.event_type.entity_declaration, e2.ty)
    1             _assert(e3.name == 'public', 'Expected system found `%s`', e3.name)
    1             _assert(e3.external_id == 'PUBLIC', 'Expected PUBLIC found `%s`', e3.external_id)
    1             _assert(e3.external_value[1] == 'public_value1', 'expected public_value1 found `%s`', e3.external_value[1])
    1             _assert(e3.external_value[2] == 'public_value2', 'expected public_value2 found `%s`', e3.external_value[2])
    1             local e4 = assert(p:next())
    1             _assert(e4.ty == event.event_type.doctype_end, 'expected %s found %s', event.event_type.doctype_end, e4.ty)
              end)
          end)
    2     describe('should parse comments', function()
    2         it('single line comment', function()
    1             local p = puller.new('<!-- This is a comment! -->')
    1             local e = assert(p:next())
    1             _assert(e.ty == event.event_type.comment, 'expected comment found %s', e.ty)
    1             _assert(e.text == ' This is a comment! ', 'bad comment text found "%s"', e.text)
              end)
          end)
    2     describe('should parse processing instruction', function()
    2         it('with content', function()
    1             local p = puller.new('<?target content?>')
    1             local e = assert(p:next())
    1             _assert(e.ty == event.event_type.processing_instruction, 'expected pi found %s', e.ty)
    1             _assert(e.target == 'target', 'bad target found "%s"', e.target)
    1             _assert(e.content == 'content', 'bad content found "%s"', e.content)
              end)
    2         it('without content', function()
    1             local p = puller.new('<?target?>')
    1             local e = assert(p:next())
    1             _assert(e.ty == event.event_type.processing_instruction, 'expected pi found %s', e.ty)
    1             _assert(e.target == 'target', 'bad target found "%s"', e.target)
    1             _assert(e.content == nil, 'bad content found "%s"', e.content)
              end)
          end)
    2     describe('should parse cdata', function ()
    1         local p = puller.new('<p><![CDATA[cdata]]></p>')
    1         local e1 = assert(p:next())
    1         _assert(e1.ty == event.event_type.open_tag, '')
    1         _assert(e1.name == 'p', 'expected `p` found `%s`', e1.name)
    1         local e2 = assert(p:next())
    1         _assert(e2.ty == event.event_type.tag_end, 'expected %s found %s', event.event_type.tag_end, e2.ty)
    1         local e3 = assert(p:next())
    1         _assert(e3.ty == event.event_type.cdata, 'expecting %s found %s', event.event_type.tag_end, e3.ty)
    1         _assert(e3.text == 'cdata', 'expected cdata found %s', e3.text)
    1         local e4 = assert(p:next())
    1         _assert(e4.ty == event.event_type.close_tag, 'Expected %s, found `%s`', event.event_type.close_tag, e4.ty)
    1         _assert(e4.name == 'p', 'exepected p found `%s`', e4.name)
          end)
      end)

==============================================================================
Summary
==============================================================================

File                                                              Hits Missed Coverage
--------------------------------------------------------------------------------------
./buffer.lua                                                      86   3      96.63%
./event.lua                                                       80   3      96.39%
./spec/char_maps.lua                                              588  0      100.00%
./xml-puller.lua                                                  282  118    70.50%
/usr/local/share/lua/5.3/busted/block.lua                         64   31     67.37%
/usr/local/share/lua/5.3/busted/compatibility.lua                 15   19     44.12%
/usr/local/share/lua/5.3/busted/context.lua                       37   42     46.84%
/usr/local/share/lua/5.3/busted/core.lua                          78   116    40.21%
/usr/local/share/lua/5.3/busted/environment.lua                   9    12     42.86%
/usr/local/share/lua/5.3/busted/execute.lua                       19   21     47.50%
/usr/local/share/lua/5.3/busted/init.lua                          23   56     29.11%
/usr/local/share/lua/5.3/busted/languages/en.lua                  38   0      100.00%
/usr/local/share/lua/5.3/busted/modules/files/lua.lua             10   1      90.91%
/usr/local/share/lua/5.3/busted/modules/files/moonscript.lua      6    46     11.54%
/usr/local/share/lua/5.3/busted/modules/filter_loader.lua         29   40     42.03%
/usr/local/share/lua/5.3/busted/modules/output_handler_loader.lua 9    10     47.37%
/usr/local/share/lua/5.3/busted/modules/test_file_loader.lua      44   10     81.48%
/usr/local/share/lua/5.3/busted/outputHandlers/base.lua           67   35     65.69%
/usr/local/share/lua/5.3/busted/outputHandlers/utfTerminal.lua    60   53     53.10%
/usr/local/share/lua/5.3/busted/runner.lua                        55   67     45.08%
/usr/local/share/lua/5.3/busted/status.lua                        22   2      91.67%
/usr/local/share/lua/5.3/busted/utils.lua                         13   8      61.90%
/usr/local/share/lua/5.3/luarocks/core/dir.lua                    13   6      68.42%
/usr/local/share/lua/5.3/luarocks/core/manif.lua                  12   42     22.22%
/usr/local/share/lua/5.3/luarocks/core/path.lua                   25   44     36.23%
/usr/local/share/lua/5.3/luarocks/loader.lua                      24   57     29.63%
/usr/local/share/lua/5.3/luassert/assert.lua                      2    80     2.44%
/usr/local/share/lua/5.3/mediator.lua                             41   26     61.19%
/usr/local/share/lua/5.3/pl/List.lua                              62   156    28.44%
/usr/local/share/lua/5.3/pl/class.lua                             20   82     19.61%
/usr/local/share/lua/5.3/pl/dir.lua                               64   179    26.34%
/usr/local/share/lua/5.3/pl/path.lua                              37   190    16.30%
/usr/local/share/lua/5.3/pl/tablex.lua                            27   377    6.68%
/usr/local/share/lua/5.3/pl/types.lua                             5    57     8.06%
/usr/local/share/lua/5.3/pl/utils.lua                             9    205    4.21%
/usr/local/share/lua/5.3/say/init.lua                             10   15     40.00%
/usr/local/share/lua/5.3/term/colors.lua                          3    14     17.65%
spec/buffer_spec.lua                                              78   0      100.00%
spec/puller_spec.lua                                              94   1      98.95%
--------------------------------------------------------------------------------------
Total                                                             2160 2224   49.27%
